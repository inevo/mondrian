<html>
<!--
  == $Id$
  == This software is subject to the terms of the Common Public License
  == Agreement, available at the following URL:
  == http://www.opensource.org/licenses/cpl.html.
  == Copyright (C) 2001-2005 Kana Software, Inc. and others.
  == All Rights Reserved.
  == You must accept the terms of that agreement to use this software.
  == jhyde, 24 September, 2002
  -->

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>How to design a mondrian schema</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css" />
</head>

<body>
<h1>How to Design a Mondrian Schema</h1>
<p>By Julian Hyde; last updated July, 2005.</p>

<hr noshade color="#000000" size="1">

<h2>Contents</h2>
<ol>
  <li><a href="#What_is_a_schema">What is a schema?</a></li>
  <li><a href="#Schema_files">Schema files</a></li>
  <li><a href="#Cubes_and_dimensions">Logical model</a><ol>
  <li><a href="#Cube">Cube</a></li>
    <li><a href="#Measures">Measures</a></li>
    <li><a href="#Dimensions,_Hierarchies,_Levels">Dimensions, Hierarchies,
    Levels</a></li>
</ol>
    </li>
  <li><a href="#Star_schemas">Star and snowflake schemas</a>
	<ol>
		<li><a href="#Shared_dimensions">Shared dimensions</a></li>
		<li><a href="#Join_optimization">Join optimization</a></li>
	</ol></li>
	<li><a href="#Advanced_logical_constructs">Advanced logical constructs</a>
	<ol>
		<li><a href="#Virtual_cubes">Virtual cubes</a></li>
		<li><a href="#Shared_dimensions">Shared dimensions</a></li>
		<li><a href="#Parent_child_hierarchies">Parent-child hierarchies</a></li>
		<li><a href="#Member_properties">Member properties</a></li>
		<li><a href="#Calculated_members">Calculated members</a></li>
		<li><a href="#Named_sets">Named sets</a></li>
	</ol></li>
	<li><a href="#Plugins">Plugins</a>
	<ol>
		<li><a href="#User-defined_function">User-defined function</a></li>
		<li><a href="#Member_reader">Member reader</a></li>
		<li><a href="#Cell_reader">Cell reader</a></li>
		<li><a href="#Cell_formatter">Cell formatter</a></li>
		<li><a href="#Member_formatter">Member formatter</a></li>
		<li><a href="#Property_formatter">Property formatter</a></li>
		<li><a href="#Schema_processor">Schema processor</a></li>
	</ol></li>
	<li><a href="#I18n">Internationalization</a></li>
	<li><a href="#Aggregate_tables">Aggregate tables</a> </li>
	<li><a href="#Access_control">Access-control</a>
	<ol>
		<li><a href="#Defining_roles">Defining a role</a></li>
		<li><a href="#Setting_a_connections_role">Setting a connection's role</a></li>
	</ol></li>
	<li><a href="#Appendix_A_XML_elements">Appendix A: XML elements</a></li>
</ol>
<h2><a name="What_is_a_schema">What is a schema?</a></h2>
<p>A schema defines a multi-dimensional database. It contains a logical model,
consisting of cubes, hierarchies, and members, and a mapping of this model onto
a physical model.</p>
<p>The logical model consists of the constructs used to write queries in MDX
language: cubes, dimensions, hierarchies, levels, and members.</p>
<p>The physical model is the source of the data which is presented through the
logical model. It is typically a star schema, which is a set of tables in a
relational database; later, we shall see examples of other kinds of mappings.</p>
<h2><a name="Schema_files">Schema files</a></h2>
<p>Mondrian schemas are represented in an XML file. An example schema,
containing almost all of the constructs we discuss here, is supplied as <code>
<a href="../demo/FoodMart.xml">demo/ dMart.xml</a></code>. The dataset to 
populate this schema is available as part of the
<a href="install.html#3_Set_up_test_data">mondrian distribution</a>.</p>
<p>Currently, the only way to create a schema is to edit a schema XML file in a
text editor. The XML syntax is not too complicated, so this is not as difficult
as it sounds, particularly if you use the&nbsp; dMart schema as a guiding example.
We are also developing a graphical workbench (written in Swing) to create and modify
schemas.</p>
<h2><a name="Cubes_and_dimensions">Logical model</a></h2>
<p>The most important components of a schema are cubes, measures, and
dimensions:</p>
<ul>
  <li>A <dfn>cube</dfn> is a collection of
  dimensions and measures in a particular subject area. </li>
  <li>A <dfn>measure</dfn> is a quantity that you are
interested in measuring, for example, unit sales of a product, or cost price of
inventory items.</li>
  <li>A <dfn>dimension</dfn> is an attribute, or set of
attributes, by which you can divide measures into sub-categories. For example,
you might wish to break down product sales by their color, the gender of the
customer, and the store in which the product was sold; color, gender, and store
are all dimensions.</li>
</ul>
<p>Let's look at the XML definition of a simple schema.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Schema">Schema</a>&gt;
  &lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
    &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot;&gt;
      &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Genders&quot; primaryKey=&quot;customer_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;customer&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot;/&gt;
      &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
    &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Time&quot; foreignKey=&quot;time_id&quot;&gt;
      &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_day&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
            uniqueMembers=&quot;true&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Quarter&quot; column=&quot;quarter&quot;
            uniqueMembers=&quot;false&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Month&quot; column=&quot;month_of_year&quot; type=&quot;Numeric&quot;
            uniqueMembers=&quot;false&quot;/&gt;
      &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
    &lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot;
        aggregator=&quot;sum&quot; formatString=&quot;#,###&quot;/&gt;
    &lt;<a href="#XML_Measure">Measure</a> name=&quot;Store Sales&quot; column=&quot;store_sales&quot;
        aggregator=&quot;sum&quot; formatString=&quot;#,###.##&quot;/&gt;
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a> name=&quot;Profit&quot; dimension=&quot;Measures&quot;
        formula=&quot;[Measures].[Store Sales]-[Measures].[Store Cost]&quot;&gt;
      &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;
  &lt;/<a href="#XML_Cube">Cube</a>&gt;
&lt;/<a href="#XML_Schema">Schema</a>&gt;</pre>
</blockquote>
<p>This schema contains a single cube, called &quot;Sales&quot;. The Sales cube has two
dimensions, &quot;Time&quot;, and &quot;Gender&quot;, and two measures, &quot;Unit Sales&quot; and &quot;Store
Sales&quot;.</p>
<p>We can write an MDX query on this schema:</p>
<blockquote>
<p><code>SELECT {[Measures].[Unit Sales], [Measures].[Store Sales]} ON COLUMNS,<br>
&nbsp; {[Time].[1997].[Q1].descendants} ON ROWS<br>
FROM [Sales]<br>
WHERE [Gender].[F]</code></p>
</blockquote>
<p>This query refers to the Sales cube (<code>[Sales]</code>), each of the
dimensions <code>[Measures]</code>, <code>[Time]</code>, <code>[Gender</code>],
and various members of those dimensions. The results are as follows:</p>
<blockquote>
  <table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="AutoNumber1">
    <tr>
      <th align="left">[Time]</th>
      <th>[Measures].[Unit Sales]</th>
      <th>[Measures].[Store Sales]</th>
    </tr>
    <tr>
      <th align="left">[1997].[Q1]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Jan]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Feb]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Mar]</th>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>
</blockquote>
<p>Now let's look at the schema definition in more detail.</p>
<h3><a name="Cube">Cube</a></h3>
<p>A cube (see <code><a href="#XML_Cube">&lt;Cube&gt;</a></code>) is a named collection of measures and dimensions. The one thing the measures and
dimensions have in common is the fact table, here <code>&quot;sales_fact_1997&quot;</code>.
As we shall see, the fact table holds the columns from which measures are
calculated, and contains references to the tables which hold the dimensions.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
  ...
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>The fact table is defined using the <a href="#XML_Table">&lt;Table&gt;</a> element.
If the fact table is not in the default schema, you can provide an explicit
schema using the &quot;schema&quot; attribute, for example</p>
<blockquote>
  <pre>&lt;<a href="#XML_Table">Table</a> schema=&quot; dmart&quot; name=&quot;sales_fact_1997&quot;/&gt;</pre>
</blockquote>
<p>You can also use the <code><a href="#XML_View">&lt;View&gt;</a></code> and <code>
<a href="#XML_Join">&lt;Join&gt;</a></code> constructs to build more complicated SQL
statements.</p>
<h3><a name="Measures">Measures</a></h3>
<p>The Sales cube defines two measures, &quot;Unit Sales&quot; and &quot;Store Sales&quot;.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot;
    aggregator=&quot;sum&quot; formatString=&quot;#,###&quot;/&gt;
&lt;<a href="#XML_Measure">Measure</a> name=&quot;Store Sales&quot; column=&quot;store_sales&quot;
    aggregator=&quot;sum&quot; formatString=&quot;#,###.00&quot;/&gt;</pre>
</blockquote>
<p>Each measure (see <a href="#XML_Measure">&lt;Measure&gt;</a>) has a name,
a column in the fact table, and an <code>aggregator</code>. The aggregator is usually &quot;sum&quot;,
but &quot;count&quot;, &quot;mix&quot;, &quot;max&quot;, &quot;avg&quot;, and &quot;distinct count&quot; are also allowed;
&quot;distinct count&quot; has some limitations if your cube contains a
<a href="#Parent_child_hierarchies">parent-child hierarchy</a>.</p>

<p>An optional <code>formatString</code> attribute specifies how the value is to
be printed. Here, we have chosen to output unit sales with no decimal places
(since it is an integer), and store sales with two decimal places (since it is a
currency value). The ',' and '.' symbols are locale-sensitive, so if you were
running in Italian, store sales might appear as &quot;48.123,45&quot;. You can achieve
even more wild effects using <a href="#Format_strings">advanced format strings</a>.</p>
<p>A measure can have a caption attribute to be returned by the <code>
<a href="api/mondrian/olap/Member.html#getCaption()">Member.getCaption()</a></code> 
method instead of the name. Defining a specific caption does make sense if 
special letters (e.g. &#931; or &#928;) are to be displayed:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;Sum X&quot; column=&quot;sum_x&quot; aggregator=&quot;sum&quot; caption=&quot;&amp;#931; X&quot;/&gt;
</blockquote>
<p>Rather than coming from a column, a measure can use a
<a href="#Cell_reader">cell reader</a>.</p>
<p>In order to provide a specific formatting of the cell values, a measure can use a
<a href="#Cell_formatter">cell formatter</a>.</p>

<h3><a name="Dimensions,_Hierarchies,_Levels">Dimensions, Hierarchies, Levels</a></h3>
<p>The <code>Gender</code> dimension consists of a single hierarchy, which has just one
level.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot;&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;customer_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;customer&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</pre>
</blockquote>
<p>For any given sale, the gender dimension is the gender of the customer who
made that purchase. This is expressed by joining from the fact table
&quot;sales_fact_1997.customer_id&quot; to the dimension table &quot;customer.customer_id&quot;.</p>
<p>The &quot;gender&quot; column contains two values, 'F' and 'M', so the Gender dimension
contains the members <code>[Gender].[F]</code> and <code>[Gender].[M]</code>. Because <code>hasAll=&quot;true&quot;</code>, the system generates a special level 
called '<code>(All)</code>', containing a single member called <code>[Gender].[All Gender]</code>. 
You can override these names using the <code>allLevelName</code> and <code>
allMemberName</code> attributes of the <code>&lt;<a href="#XML_Hierarchy">Hierarchy</a>&gt;</code> 
element.</p>

<p>A dimension can contain more than one hierarchy:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Time&quot; foreignKey=&quot;time_id&quot;&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_day&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;true&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Quarter&quot; column=&quot;quarter&quot;
        uniqueMembers=&quot;false&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Month&quot; column=&quot;month_of_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;false&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> name=&quot;Time Weekly&quot; hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_week&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;true&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Week&quot; column=&quot;week&quot;
        uniqueMembers=&quot;false&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Day&quot; column=&quot;day_of_week&quot; type=&quot;String&quot;
        uniqueMembers=&quot;false&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</pre>
</blockquote>
<p>Notice that the first hierarchy doesn't have a name. By default, a hierarchy
has the same name as its dimension, so the first hierarchy is called &quot;Time&quot;.</p>
<p>These hierarchies don't have much in common &mdash; they don't even have the same
table! &mdash; except that they are joined from the same column in the fact table,
<code>&quot;time_id&quot;</code>. The main reason to put two hierarchies in the same
dimension is because it makes more sense to the end-user: end-users know that it
makes no sense to have the &quot;Time&quot; hierarchy on one axis and the &quot;Time Weekly&quot;
hierarchy on another axis. If two hierarchies are the same dimension, the MDX
language enforces common sense, and does not allow you to use them both in the
same query.</p>
<p>A dimension is joined to a cube by means of a pair of columns. The 
&lt;Dimension&gt; element has a primaryKey attribute, which is the name of a column in 
the fact table; while the Hierarchy element has an element , one in the fact 
table, the other in the dimension table. The </p>

<p>A dimension can live in the fact table:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
  ...
  &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Payment method&quot;&gt;
    &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot;&gt;
      &lt;<a href="#XML_Level">Level</a> name=&quot;Payment method&quot; column=&quot;payment_method&quot; uniqueMembers=&quot;true&quot;/&gt;
    &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>Each dimension contains a single hierarchy, which is made up of a number levels.</p>

<p>Some more definitions:</p>
<ul>
  <li>A <dfn>member</dfn> is a point within a dimension
determined by a particular set of attribute values. The gender hierarchy has
the two members 'M' and 'F'. 'San Francisco', 'California' and 'USA' are all
members of the store hierarchy.</li>
  <li>A <dfn>hierarchy</dfn> is a set of related
attributes (or <dfn>levels</dfn>) which collectively
form a dimension. For example, the store hierarchy consists of the store name,
city, state, and nation. The hierarchy allows you form intermediate sub-totals:
the sub-total for a state is the sum of the sub-totals of all of the cities in
that state, each of which is the sum of the sub-totals of the stores in that
city.</li>
</ul>
<p>For reasons of uniformity, measures are treated as members of a special
dimension, called 'Measures'.</p>
<p>Most dimensions have just one hierarchy, but occasionally a dimension has
more than one. For example, you might wish to aggregate days from the Time
dimension into months, quarters, and years; or into weeks and years. Both
hierarchies start off with days and end with years, but aggregate using
different paths.</p>

<p>By default, every hierarchy contains a top level called '<code>(All)</code>', which 
contains a single member called '<code>(All {<i>hierarchyName</i>})</code>'. 
This member is parent of all other members of the hierarchy, and thus represents 
a grand total. If the <code>&lt;Hierarchy&gt;</code> element has <code>
hasAll=&quot;false&quot;</code>, the 'all' level is suppressed; the <code>allMemberName</code> and 
<code>allLevelName</code> attributes override the default names of the all level 
its member.</p>

<p>As we shall see later, a level definition can also define
<a href="#Member_properties">member properties</a> and a
<a href="#Member_formatter">member formatter</a>.</p>

<h2><a name="Star_schemas">Star and snowflake schemas</a></h2>
<p>We saw earlier how to build a cube based upon a fact table, and dimensions in
the fact table (&quot;Payment method&quot;) and in a table joined to the fact table
(&quot;Gender&quot;). This is the most common kind of mapping, and is known as a <dfn>
star schema</dfn>.</p>
<p>But a dimension can be based upon more than one table, provided that there is
a well-defined path to join these tables to the fact table. This kind of
dimension is known as a snowflake, and is defined using the <code>&lt;Join&gt;</code>
operator. For example:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  ...
  &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Product&quot; foreignKey=&quot;product_id&quot;&gt;
    &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;product_id&quot; primaryKeyTable=&quot;product&quot;&gt;
      &lt;Join leftKey=&quot;product_class_id&quot; rightAlias=&quot;product_class&quot; rightKey=&quot;product_class_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;product&quot;/&gt;
        &lt;Join leftKey=&quot;product_type_id&quot; rightKey=&quot;product_type_id&quot;&gt;
          &lt;<a href="#XML_Table">Table</a> name=&quot;product_class&quot;/&gt;
          &lt;<a href="#XML_Table">Table</a> name=&quot;product_type&quot;/&gt;
        &lt;/Join&gt;
      &lt;/Join&gt;
      ...
    &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>This defines a <code>&quot;Product&quot;</code> dimension consisting of three tables.
The fact table joins to <code>&quot;product&quot;</code> (via the foreign key <code>&quot;product_id&quot;</code>),
which joins to <code>&quot;product_class&quot;</code> (via the foreign key <code>&quot;product_class_id&quot;</code>),
which joins to <code>&quot;product_type&quot;</code> (via the foreign key <code>&quot;product_type_id&quot;</code>).
We require a <code>&lt;Join&gt;</code> element nested within a <code>&lt;Join&gt;</code>
element because <code>&lt;Join&gt;</code> takes two operands; the operands can be
tables, joins, or even queries.</p>
<p>The arrangement of the tables seems complex, the simple rule of thumb is to
order the tables by the number of rows they contain. The <code>&quot;product&quot;</code>
table has the most rows, so it joins to the fact table and appears first; <code>
&quot;product_class&quot;</code> has fewer rows, and <code>&quot;product_type&quot;</code>, at the
tip of the snowflake, has least of all.</p>
<p>Note that the outer <code>&lt;Join&gt;</code> element has a <code>rightAlias</code>
attribute. This is necessary because the right component of the join (the inner
<code>&lt;Join&gt;</code> element) consists of more than one table. No <code>leftAlias</code>
attribute is necessary in this case, because the leftKey column unambiguously
comes from the <code>&quot;product&quot;</code> table.</p>
<h3><a name="Shared_dimensions">Shared dimensions</a></h3>
<p>When generating the SQL for a join, mondrian needs to know which column to
join to. If you are joining to a join, then you need to tell it which of the
tables in the join that column belongs to (usually it will be the first table in
the join).</p>
<p>Because shared dimensions don't belong to a cube, you have to give them an
explicit table (or other data source). When you use them in a particular cube,
you specify the foreign key. This example shows the <code>Store Type</code>
dimension being joined to the <code>Sales</code> cube using the <code>
sales_fact_1997.store_id</code> foreign key, and to the <code>Warehouse</code>
cube using the <code>warehouse.warehouse_store_id</code> foreign key:</p>
<blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Store Type&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;store_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;store&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Store Type&quot; column=&quot;store_type&quot; uniqueMembers=&quot;true&quot;/&gt;<br>
&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;<br>
	<br>
	&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;<br>
&nbsp; ...<br>
&nbsp; &lt;<a href="#XML_DimensionUsage">DimensionUsage</a> name=&quot;Store Type&quot; source=&quot;Store Type&quot; foreignKey=&quot;store_id&quot;/&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;<br>
	<br>
	&lt;<a href="#XML_Cube">Cube</a> name=&quot;Warehouse&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;warehouse&quot;/&gt;<br>
&nbsp; ...<br>
&nbsp; &lt;<a href="#XML_DimensionUsage">DimensionUsage</a> name=&quot;Store Type&quot; source=&quot;Store Type&quot; foreignKey=&quot;warehouse_store_id&quot;/&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>
<h3><a name="Join_optimization">Join optimization</a></h3>
<p>The table mapping in the schema tells Mondrian how to get the data, but
Mondrian is smart enough not to read the schema literally. It applies a number
of optimizations when generating queries:</p>
<ul>
  <li>If a dimension has a small number of members, Mondrian reads it into a
  cache on first use. See the
  <a href="api/mondrian/olap/MondrianProperties.html#getLargeDimensionThreshold()">
  mondrian.rolap.LargeDimensionThreshold</a> property.</li>
  <li>If a dimension (or, more precisely, the level of the dimension being
  accessed) is in the fact table, Mondrian does not perform a join.</li>
  <li>If two dimensions access the same table via the same join path, Mondrian
  only joins them once. For example, <code>[Gender]</code> and <code>[Age]</code>
  might both be columns in the <code>customers</code> table, joined via <code>
  sales_1997.cust_id = customers.cust_id</code>.</li>
</ul>
<h2><a name="Advanced_logical_constructs">Advanced logical constructs</a></h2>
<h3><a name="Virtual_cubes">Virtual cubes</a></h3>
<p>Defined by the <code><a href="#XML_VirtualCube">&lt;VirtualCube&gt;</a></code> element. (To be continued...)</p>
<h3><a name="Parent_child_hierarchies">Parent-child hierarchies</a></h3>
<p>A conventional hierarchy has a rigid set of levels, and members which adhere
to those levels. For example, in the <code>Product</code> hierarchy, any member of the
<code>Product Name</code> level has a parent in the <code>Brand Name</code> level, which has a parent in
the <code>Product Subcategory</code> level, and so forth. This structure is
sometimes too rigid to model real-world data.</p>
<p>A <dfn>parent-child hierarchy</dfn> has only one level (not counting the special 'all'
level), but any member can have parents in the same level. A classic example is
the reporting structure in the <code>Employees</code> hierarchy:</p>
<blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Employees&quot; foreignKey=&quot;employee_id&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Employees&quot; primaryKey=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;employee&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Employee Id&quot; uniqueMembers=&quot;true&quot; type=&quot;Numeric&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; column=&quot;employee_id&quot; nameColumn=&quot;full_name&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentColumn=&quot;supervisor_id&quot; nullParentValue=&quot;0&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Marital Status&quot; column=&quot;marital_status&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Position Title&quot; column=&quot;position_title&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Gender&quot; column=&quot;gender&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Salary&quot; column=&quot;salary&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Education Level&quot; column=&quot;education_level&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Management Role&quot; column=&quot;management_role&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_Level">Level</a>&gt;<br>
&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code></p>
</blockquote>
<p>The important attributes here are <code>parentColumn</code> and <code>
nullParentValue</code>:</p>
<ul>
  <li>The <code>parentColumn</code> attribute is the name of the column which
  links a member to its parent member; in this case, it is the foreign key
  column which points to an employee's supervisor. The <code>&lt;ParentExpression&gt;</code>
  child element of <code>&lt;Level&gt;</code> is equivalent to the <code>parentColumn</code>
  attribute, but allows you to define an arbitrary SQL expression, just like the
  <code>&lt;Expression&gt;</code> element. The <code>parentColumn</code> attribute (or
  <code>&lt;ParentExpression&gt;</code> element) is the only indication to Mondrian
  that a hierarchy has a parent-child structure.</li>
  <li>The <code>nullParentValue</code> attribute is the value which indicates
  that a member has no parent. The default is <code>nullParentValue=&quot;null&quot;</code>,
  but since many database don't index null values, schema designers sometimes
  use values as the empty string, 0, and -1 instead.</li>
</ul>

<h4>Tuning parent-child hierarchies</h4>

<p>There's one serious problem with the parent-child hierarchy defined above,
and that is the amount of work Mondrian has to do in order to compute
cell-totals. Let's suppose that the employee table contains the following data:</p>

<blockquote>
<table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="table3">
    <tr>
        <th colspan="3">employee</th>
    </tr>
    <tr>
        <th>supervisor_id</th>
        <th>employee_id</th>
        <th>full_name</th>
    </tr>
    <tr>
        <td>null</td>
        <td>1</td>
        <td>Frank</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>Bill</td>
    </tr>
    <tr>
        <td>2</td>
        <td>3</td>
        <td>Eric</td>
    </tr>
    <tr>
        <td>1</td>
        <td>4</td>
        <td>Jane</td>
    </tr>
    <tr>
        <td>3</td>
        <td>5</td>
        <td>Mark</td>
    </tr>
    <tr>
        <td>2</td>
        <td>6</td>
        <td>Carla</td>
    </tr>
</table>
</blockquote>

<p>If we want to compute the total salary budget for Bill, we need to add in the
salaries of Eric and Carla (who report to Bill) and Mark (who reports to Eric).
Usually Mondrian generates a SQL <code>GROUP BY</code> statement to compute
these totals, but there is no (generally available) SQL construct which can
traverse hierarchies. So by default, Mondrian generates one SQL statement per
supervisor, to retrieve and total all of that supervisor's direct reports.</p>

<p>This approach has a couple of drawbacks. First, the performance is not very
good if a hierarchy contains more than a hundred members. Second, because Mondrian implements the
&quot;distinct count&quot; aggregator by generating SQL, you
cannot define a &quot;distinct count&quot; member in any cube which contains a parent-child
hierarchy.</p>

<p>How can we solve these problems? The answer is to enhance the data so that Mondrian is able to retrieve the information it needs using standard SQL. Mondrian supports 
a mechanism called a <dfn>closure table</dfn> for 
this purpose.</p>

<p>A closure table is a SQL table which contains a record for every
employee/supervisor relationship, regardless of depth. (In mathematical terms,
this is called the 'reflexive transitive closure' of the employee/supervisor
relationship. The <code>distance</code> column is not strictly required, but it
makes it easier to populate the table.)</p>

<blockquote>
<table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="table3">
    <tr>
        <th colspan="3">employee_closure</th>
    </tr>
    <tr>
        <th width="91">supervisor_id</th>
        <th width="85">employee_id</th>
        <th width="8">distance</th>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">1</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">2</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">3</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">4</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">5</td>
        <td width="8">3</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">6</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">2</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">3</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">5</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">6</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">3</td>
        <td width="85">3</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">3</td>
        <td width="85">5</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">4</td>
        <td width="85">4</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">5</td>
        <td width="85">5</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">6</td>
        <td width="85">6</td>
        <td width="8">0</td>
    </tr>
    </table>
</blockquote>

<p>In the catalog XML, the <code>&lt;<a href="#XML_Closure">Closure</a>&gt;</code>
element maps the level onto a <code>&lt;<a href="#XML_Table">Table</a>&gt;</code>:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Employees&quot; foreignKey=&quot;employee_id&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Employees&quot; primaryKey=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;employee&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Employee Id&quot; uniqueMembers=&quot;true&quot; type=&quot;Numeric&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; column=&quot;employee_id&quot; nameColumn=&quot;full_name&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentColumn=&quot;supervisor_id&quot; nullParentValue=&quot;0&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Closure">Closure</a> parentColumn=&quot;supervisor_id&quot; childColumn=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a>
    name=&quot;employee_closure&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_Closure">Closure</a>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Marital Status&quot; column=&quot;marital_status&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Position Title&quot; column=&quot;position_title&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Gender&quot; column=&quot;gender&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Salary&quot; column=&quot;salary&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Education Level&quot; column=&quot;education_level&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Management Role&quot; column=&quot;management_role&quot;/&gt;<br>
&nbsp;&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code></p>
</blockquote>

<p>This table allows totals to be evaluated in pure SQL. Even though
this introduces an extra table into the query, database optimizers are very good at
handling joins. I recommend that you declare both <code>supervisor_id</code>
and <code>employee_id</code> NOT NULL, and index them as follows:</p>

<blockquote>

    <p><code>CREATE UNIQUE INDEX employee_closure_pk ON employee_closure (<br>
&nbsp;&nbsp; supervisor_id,<br>
&nbsp;&nbsp; employee_id<br>
    );<br>
    CREATE INDEX employee_closure_emp ON employee_closure (<br>
&nbsp;&nbsp; employee_id<br>
    );</code></p>
</blockquote>

<p>The table needs to be re-populated whenever the hierarchy changes, and it is
the application's responsibility to do so -- Mondrian does not do this!
Here is an example of a stored procedure that computes a closure table.</p>

<blockquote><p>
<code>CREATE PROCEDURE close_employee()<br>
BEGIN<br>
&nbsp; DECLARE distance int;<br>
&nbsp; TRUNCATE TABLE employee_closure;<br>
&nbsp; SET distance = 0;<br>
&nbsp;
  <i>-- seed closure with self-pairs (distance 0)</i><br>
&nbsp; INSERT INTO employee_closure (supervisor_id, employee_id, distance)<br>
&nbsp;&nbsp;&nbsp; SELECT employee_id, employee_id, distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM employee;<br>
<br>
&nbsp;

  <i>-- for each pair (root, leaf) in the closure,<br>
&nbsp; -- add (root, leaf->child) from the base table</i><br>
&nbsp; REPEAT<br>
&nbsp;&nbsp;&nbsp; SET distance = distance + 1;<br>
&nbsp;&nbsp;&nbsp; INSERT INTO employee_closure (supervisor_id, employee_id, distance)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT employee_closure.supervisor_id, employee.employee_id, distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM employee_closure, employee<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE employee_closure.employee_id = employee.supervisor_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND employee_closure.distance = distance - 1;<br>
&nbsp; UNTIL (ROW_COUNT() == 0))<br>
&nbsp; END REPEAT<br>
END</code><code><br>
</p></code></blockquote>


<h3><a name="Member_properties">Member properties</a></h3>

<p>Member properties are defined by the <code><a href="#XML_Property">&lt;Property&gt;</a></code> 
element within a <code>&lt;<a href="#XML_Level">Level</a>&gt;</code>, like this:</p>

<blockquote>
  <pre>
&lt;<a href="#XML_Level">Level</a> name=&quot;MyLevel&quot; column=&quot;LevelColumn&quot; uniqueMembers=&quot;true&quot;/&gt;
  &lt;<a href="#XML_Property">Property</a> name=&quot;MyProp&quot; column=&quot;PropColumn&quot; formatter=&quot;com.acme.MyPropertyFormatter&quot;/&gt;
&lt;<a href="#XML_Level">Level</a>/&gt;</pre>
</blockquote>

<p>The <code>formatter</code> attribute defines a <a href="#Property_formatter">property 
formatter</a>, which is explained later.</p>

<p>Once properties have been defined in the schema, you can use them in MDX 
statements via the <code><i>member</i>.Properties(&quot;<i>propertyName</i>&quot;)</code>
function, for example:</p><blockquote>
  <code>SELECT {[Store Sales]} ON COLUMNS,<br>
&nbsp; TopCount(Filter([Store].[Store Name].Members,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    [Store].CurrentMember.Properties(&quot;Store Type&quot;) = &quot;Supermarket&quot;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Store Sales]) ON ROWS<br>
	FROM [Sales]</code></blockquote>

<p>Mondrian deduces the type of the property expression, if it can. If the
property name is a constant string, the type is based upon the type attribute
(&quot;String&quot;, &quot;Numeric&quot; or &quot;Boolean&quot;) of the property definition. If the property
name is an expression (for example <code>CurrentMember.Properties(&quot;Store &quot; +
&quot;Type&quot;)</code>), Mondrian will return an untyped value.</p>

<h3><a name="Calculated_members">Calculated members</a></h3>

<p>Suppose you want to create a measure whose value comes not from a
column of the fact table, but from an MDX formula. One way to do this is to use
a <code>WITH MEMBER</code> clause, like this:</p>

<blockquote>

    <p><code>WITH MEMBER [Measures].[Profit] AS '[Measures].[Store
    Sales]-[Measures].[Store Cost]',<br>
&nbsp;&nbsp; FORMAT_STRING = '$#,###'<br>
    SELECT {[Measures].[Store Sales], [Measures].[Profit]} ON COLUMNS,<br>
&nbsp; {[Product].Children} ON ROWS<br>
    FROM [Sales]<br>
    WHERE [Time].[1997]</code></p>
</blockquote>
<p>But rather than including this clause in every MDX query of your application,
you can define the member in your schema, as part of your cube definition:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_CalculatedMember">CalculatedMember</a> name=&quot;Profit&quot; dimension=&quot;Measures&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Formula">Formula</a>&gt;[Measures].[Store Sales] - [Measures].[Store 
	Cost]&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;<br>
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code></p>
</blockquote>

<p>You can also declare the formula as an XML attribute, if you prefer. The 
effect is just the same.</p>

<blockquote>

    <p><code>&lt;<a href="#XML_CalculatedMember">CalculatedMember</a> name=&quot;Profit&quot; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; formula=&quot;[Measures].[Store Sales]-[Measures].[Store Cost]&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;<br>
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code></p>
</blockquote>

<p>Note that the <code>&lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a>&gt;</code>
(not <code>&lt;<a href="#XML_Property">Property</a>&gt;</code>) element corresponds
to the <code>FORMAT_STRING = '$#,###'</code> fragment of the MDX statement. You
can define other properties here too, but <code>FORMAT_STRING</code> is by far
the most useful in practice.</p>

<p>The <code>FORMAT_STRING</code> property value can also be evaluated using an expression. When
formatting a particular cell, first the expression is evaluated to yield a
format string, then the format string is applied to the cell value. Here is the
same property with a conditional format string:</p>

<blockquote>

    <p><code>&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a>
    name=&quot;FORMAT_STRING&quot; expression=&quot;Iif(Value &lt; 0, '|($#,##0.00)|style=red',
    '|$#,##0.00|style=green')&quot;/&gt;</code></p>
</blockquote>

<p>For more details about format strings, see the
<a href="mdx.html#Format_strings">MDX specification</a>.</p>

<p>You can make a calculated member or a measure invisible. If you specify <code>
visible=&quot;false&quot;</code> (the default is &quot;true&quot;) in the <code>&lt;<a href="#XML_Measure">Measure</a>&gt;
or &lt;<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code> element,
user-interfaces such as JPivot will notice this property and hide the member.
This is useful if you want to perform calculations in a number of steps, and
hide intermediate steps from end-users. For example, here only &quot;Margin per Sqft&quot;
is visible, and its factors &quot;Store Cost&quot;, &quot;Margin&quot; and &quot;Store Sqft&quot; are hidden:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_Measure">Measure</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Store Cost&quot;<br>
&nbsp;&nbsp;&nbsp; column=&quot;store_cost&quot;<br>
&nbsp;&nbsp;&nbsp; aggregator=&quot;sum&quot;<br>
&nbsp;&nbsp;&nbsp; formatString=&quot;#,###.00&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;/&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Margin&quot; <br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot; <br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Formula">Formula</a>&gt;([Measures].[Store Sales] - [Measures].[Store Cost])
    / [Measures].[Store Cost]&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Store Sqft&quot; <br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Formula">Formula</a>&gt;[Store].Properties(&quot;Sqft&quot;)&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Margin per Sqft&quot;<br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;true&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Formula">Formula</a>&gt;[Measures].[Margin] / [Measures].[Store 
	Cost]&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;<br>
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code></p>
</blockquote>

<h3><a name="Named_sets">Named sets</a></h3>

<p>The <code>WITH SET</code> clause of an MDX statement allows you to declare a 
set expression which can be used throughout that query. For example,</p>

<blockquote>

	<p><code><font color="#FF0000"><b>WITH SET [Top Sellers] AS <br>
&nbsp;&nbsp;&nbsp; 'TopCount([Warehouse].[Warehouse Name].MEMBERS, 5, 
	[Measures].[Warehouse Sales])'</b></font><br>
	SELECT <br>
&nbsp;&nbsp;&nbsp; {[Measures].[Warehouse Sales]} ON COLUMNS,<br>
&nbsp;&nbsp;&nbsp; {<font color="#FF0000">[Top Sellers]</font>} ON ROWS<br>
	FROM [Warehouse]<br>
	WHERE [Time].[Year].[1997]</code></p>
</blockquote>

<p>The <code>WITH SET</code> clause is very similar to the <code>WITH MEMBER</code> 
clause, and as you might expect, it has a construct in schema analogous to
<code>&lt;<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code>. The <code>&lt;<a href="#XML_NamedSet">NamedSet</a>&gt;</code> element allows 
you to define a named set in your schema as part of a cube definition. It is 
implicitly available for any query against that cube:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Warehouse&quot;&gt;<br>
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&lt;<a href="#XML_NamedSet">NamedSet</a> name=&quot;Top Sellers&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;<a href="#XML_Formula">Formula</a>&gt;TopCount([Warehouse].[Warehouse Name].MEMBERS, 
	5, 
	[Measures].[Warehouse Sales])&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
&nbsp;&nbsp;&lt;/<a href="#XML_NamedSet">NamedSet</a>&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>

	<p><code>SELECT <br>
&nbsp;&nbsp;&nbsp; {[Measures].[Warehouse Sales]} ON COLUMNS,<br>
&nbsp;&nbsp;&nbsp; {<font color="#FF0000">[Top Sellers]</font>} ON ROWS<br>
	FROM [Warehouse]<br>
	WHERE [Time].[Year].[1997]</code></p>
	<table id="table4" border="1" cellspacing="0" cellpadding="2">
		<tr>
			<th>

			<p align="left">Warehouse</th>
			<th>Warehouse Sales</th>
		</tr>
		<tr>
			<td>Treehouse Distribution</td>
			<td align="right">31,116.37</td>
		</tr>
		<tr>
			<td>Jorge Garcia, Inc.</td>
			<td align="right">30,743.77</td>
		</tr>
		<tr>
			<td>Artesia Warehousing, Inc.</td>
			<td align="right">29,207.96</td>
		</tr>
		<tr>
			<td>Jorgensen Service Storage</td>
			<td align="right">22,869.79</td>
		</tr>
		<tr>
			<td>Destination, Inc.</td>
			<td align="right">22,187.42</td>
		</tr>
	</table>
</blockquote>
	<DOC>

<p>A named set defined against a cube is not inherited by a virtual cubes 
	defined against that cube. (But you can define a named set against a virtual 
	cube.)</p>

<p>You can also define a named set as global to a schema:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Schema</a>&gt;<br>
&nbsp; &lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot; ... /&gt;<br>
&nbsp; &lt;<a href="#XML_Cube">Cube</a> name=&quot;Warehouse&quot; ... /&gt;<br>
&nbsp; &lt;<a href="#XML_VirtualCube">VirtualCube</a> name=&quot;Warehouse and Sales&quot; 
	.../&gt;<br>
&nbsp; &lt;<a href="#XML_NamedSet">NamedSet</a> name=&quot;CA Cities&quot; 
	formula=&quot;{[Store].[USA].[CA].Children}&quot;/&gt;<br>
&nbsp; &lt;<a href="#XML_NamedSet">NamedSet</a> name=&quot;Top CA Cities&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Formula">Formula</a>&gt;TopCount([CA Cities], 2, 
	[Measures].[Unit Sales])&lt;/<a href="#XML_Formula">Formula</a>&gt;<br>
&nbsp; &lt;/<a href="#XML_NamedSet">NamedSet</a>&gt;<br>
	&lt;/<a href="#XML_Cube">Schema</a>&gt;</code></p>
</blockquote>

	<p>A named set defined against a schema is available in all cubes and 
	virtual cubes in that schema. However, it is only valid if the cube contains 
	dimensions with the names required to make the formula valid. For example, 
	it would be valid to use <code>[CA Cities]</code> in queries against the
	<code>[Sales]</code> and <code>[Warehouse and Sales]</code> cubes, but if 
	you used it in a query against the <code>[Warehouse]</code> cube you would 
	get an error, because <code>[Warehouse]</code> does not have a <code>[Store]</code> 
	dimension.</p>

<h2><a name="Plugins">Plug-ins</a></h2>

<p>Sometimes Mondrian's schema language isn't flexible enough, or the MDX 
language isn't powerful enough, to solve the problem at hand. What you want to 
do is add a little of your own Java code into the Mondrian application, and a
<dfn>plug-in</dfn> is a way to do this.</p>

<p>Each of Mondrian's extensions is technically a Service Provider Interface (SPI); 
in short, a Java interface which you write code to implement, and which Mondrian 
will call at runtime. You also need to register an extension (usually somewhere 
in your schema.xml file) and to ensure that it appears on the classpath.</p>

<p>Plug-ins include <a href="#User-defined_function">user-defined functions</a>;
<a href="#Cell_formatter">cell</a>, <a href="#Member_formatter">member</a> and
<a href="#Property_formatter">property formatters</a>; and
<a href="#Schema_processor">dynamic schema processors</a>. There is incomplete 
support for <a href="#Member_reader">member readers</a> and
<a href="#Cell_reader">cell readers</a>, and in future we may support pluggable
<a href="api/mondrian/rolap/sql/SqlQuery.Dialect.html">SQL dialects</a>.</p>

<h3><a name="User-defined_function">User-defined function</a></h3>

<p>A user-defined function must have a public constructor and implement the
<a href="api/mondrian/spi/UserDefinedFunction.html">
mondrian.spi.UserDefinedFunction</a><b> </b>interface. For example,</p>

<blockquote>

	<p><code>package com.acme;<br>
	<br>
	import mondrian.olap.*;<br>
	import mondrian.olap.type.*;<br>
	import mondrian.spi.UserDefinedFunction;<br>
	<br>
	/**<br>
&nbsp;* A simple user-defined function which adds one to its argument.<br>
&nbsp;*/<br>
	public class PlusOneUdf implements UserDefinedFunction {<br>
&nbsp;&nbsp;&nbsp; // public constructor<br>
&nbsp;&nbsp;&nbsp; public PlusOneUdf() {<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public String getName() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &quot;PlusOne&quot;;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public String getDescription() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &quot;Returns its argument plus 
	one&quot;;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Syntax getSyntax() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Syntax.Function;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Type getReturnType(Type[] parameterTypes) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new NumericType();<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Type[] getParameterTypes() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Type[] {new NumericType()};<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Object execute(Evaluator evaluator, Exp[] arguments) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final Object argValue = arguments[0].evaluateScalar(evaluator);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argValue instanceof Number) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new 
	Double(((Number) argValue).doubleValue() + 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Argument 
	might be a RuntimeException indicating that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the cache 
	does not yet have the required cell value. The<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // function 
	will be called again when the cache is loaded.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public String[] getReservedWords() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>
&nbsp;&nbsp;&nbsp; }<br>
	}</code></p>
</blockquote>

<p>Declare it in your schema:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Schema">Schema</a>&gt;<br>
&nbsp; ...<br>
	&nbsp;&nbsp;&lt;<a href="#XML_UserDefinedFunction">UserDefinedFunction</a> name=&quot;PlusOne&quot; 
	class=&quot;com.acme.PlusOneUdf&quot;&gt;<br>
	&lt;/<a href="#XML_Schema">Schema</a>&gt;</code></p>
</blockquote>

<p>And use it in any MDX statement:</p>

<blockquote>

	<p><code>WITH MEMBER [Measures].[Unit Sales Plus One] <br>
&nbsp;&nbsp;&nbsp; AS '<font color="#FF0000">PlusOne([Measures].[Unit Sales])</font>'<br>
	SELECT<br>
&nbsp;&nbsp;&nbsp; {[Measures].[Unit Sales]} ON COLUMNS,<br>
&nbsp;&nbsp;&nbsp; {[Gender].MEMBERS} ON ROWS<br>
	FROM [Sales]</code></p>
</blockquote>

<p>If a user-defined function has a public constructor with one string argument, 
Mondrian will pass in the function's name. Why? This allows you to define two or 
more user-defined functions using the same class:</p>

<blockquote>

	<p><code>package com.acme;<br>
	<br>
	import mondrian.olap.*;<br>
	import mondrian.olap.type.*;<br>
	import mondrian.spi.UserDefinedFunction;<br>
	<br>
	/**<br>
&nbsp;* A user-defined function which either adds one to or <br>
&nbsp;* subtracts one from its argument.<br>
&nbsp;*/<br>
	public class PlusOrMinusOneUdf implements UserDefinedFunction {<br>
	<font color="#FF0000">&nbsp;&nbsp;&nbsp; private final name;<br>
&nbsp;&nbsp;&nbsp; private final isPlus;<br>
	<br>
	</font>&nbsp;&nbsp;&nbsp; // public constructor with one argument<br>
&nbsp;&nbsp;&nbsp; <font color="#FF0000">public PlusOneUdf(String name) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (name.equals(&quot;PlusOne&quot;)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isPlus = 
	true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (name.equals(&quot;MinusOne&quot;)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isPlus = 
	false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new 
	IllegalArgumentException(&quot;Unexpected name &quot; + name);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }</font><br>
	<br>
&nbsp;&nbsp;&nbsp; public String getName() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return name;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public String getDescription() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &quot;Returns its argument plus or 
	minus one&quot;;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Syntax getSyntax() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Syntax.Function;<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Type getReturnType(Type[] parameterTypes) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new NumericType();<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Type[] getParameterTypes() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Type[] {new NumericType()};<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public Object execute(Evaluator evaluator, Exp[] arguments) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final Object argValue = arguments[0].evaluateScalar(evaluator);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argValue instanceof Number) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#FF0000">if (isPlus) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	return new Double(((Number) argValue).doubleValue() + 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	return new Double(((Number) argValue).doubleValue() - 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; </font>&nbsp;&nbsp;&nbsp; } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Argument 
	might be a RuntimeException indicating that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the cache 
	does not yet have the required cell value. The<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // function 
	will be called again when the cache is loaded.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
	<br>
&nbsp;&nbsp;&nbsp; public String[] getReservedWords() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>
&nbsp;&nbsp;&nbsp; }<br>
	}</code></p>
</blockquote>

<p>and register two the functions in your schema:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Schema">Schema</a>&gt;<br>
&nbsp; ...<br>
	&nbsp;&nbsp;&lt;<a href="#XML_UserDefinedFunction">UserDefinedFunction</a> name=&quot;PlusOne&quot; 
	class=&quot;com.acme.PlusOrMinusOneUdf&quot;&gt;<br>
	&nbsp;&nbsp;&lt;<a href="#XML_UserDefinedFunction">UserDefinedFunction</a> name=&quot;MinusOne&quot; 
	class=&quot;com.acme.PlusOrMinusOneUdf&quot;&gt;<br>
	&lt;/<a href="#XML_Schema">Schema</a>&gt;</code></p>
</blockquote>

<h3><a name="Member_reader">Member reader</a></h3>

<p>A <dfn>member reader</dfn> is a means of
accessing members. Hierarchies are usually based upon a dimension table (an
'arm' of a star schema), and are therefore populated using SQL. But even if your
data doesn't reside in an RDBMS, you can make it appear as a hierarchy by
writing a Java class called a <dfn>custom member reader</dfn>.</p>

<p>Here are a couple of examples:</p><ol>
  <li><code>DateSource</code> (to be written) generates a time hierarchy.
  Conventionally, data warehouse implementors generate a table containing a row
  for every date their system is ever likely to deal with. But the problem is
  that this table needs to be loaded, and as time goes by, they will have to
  remember to add more rows. DateSource generates date members in memory, and on
  demand.</li><li><code>FileSystemSource</code> (to be written) presents the file system as
  a hierarchy of directories and files. Since a directory can have a parent
  which is itself a directory, it is a parent-child hierarchy. Like the time
  hierarchy created by DateSource, this is a virtual hierarchy: the member for a
  particular file is only created when, and if, that file's parent directory is
  expanded.</li><li><code>ExpressionMemberReader</code> (to be written) creates a hierarchy
  based upon an expression.</li></ol>

<p>A custom member reader must implement
the <a href="api/mondrian/rolap/MemberSource.html">mondrian.rolap.MemberSource</a> 
interface. If you need to implement a larger set of member
operations for fine-grained control, implement the derived
<a href="api/mondrian/rolap/MemberReader.html">
mondrian.rolap.MemberReader</a> interface; otherwise, Mondrian wrap your reader
in a
<a href="api/mondrian/rolap/MemberSource.html">mondrian.rolap.CacheMemberReader</a> 
object.
Your member reader must have a
public constructor which takes <code>(<a href="api/mondrian/rolap/RolapHierarchy.html">RolapHierarchy</a>, <a href="http://java.sun.com/j2se/1.4/docs/api/java/util/Properties.html">Properties</a>)</code>
parameters, and throws no checked exceptions.</p>

<p>Member readers are declared using the <code><a href="#XML_Hierarchy">&lt;Hierarchy&gt;</a></code> element's
<code>memberReaderClass</code> attribute; any <code><a href="#XML_Parameter">&lt;Parameter&gt;</a></code> child
elements are passed via the <code>properties</code> constructor parameter. Here is an example:</p><blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Has bought dairy&quot;&gt;<br>
	&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; memberReaderClass=&quot;mondrian.rolap.HasBoughtDairySource&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Has bought dairy&quot; uniqueMembers=&quot;true&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Parameter">Parameter</a> name=&quot;expression&quot; value=&quot;not used&quot;/&gt;<br>
	&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code><br>
</p></blockquote>

<h3><a name="Cell_reader">Cell reader</a></h3>

<p>Not implemented yet. Syntax would be something like</p><blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;name&quot; cellReaderClass=&quot;com.acme.MyCellReader&quot;/&gt;</pre></blockquote>

<p>and the class &quot;com.acme.MyCellReader&quot; would have to implement the
<code>
<a href="api/mondrian/olap/CellReader.html">
mondrian.olap.CellReader</a></code> interface.</p>

<h3><a name="Cell_formatter">Cell formatter</a></h3>

<p>A cell formatter modifies the behavior of
<code>
<a href="api/mondrian/olap/Cell.html#getFormattedValue()">
Cell.getFormattedValue()</a></code>. The class must implement the
<code>
<a href="api/mondrian/olap/CellFormatter.html">
mondrian.olap.CellFormatter</a></code> interface, and is specified like this:</p><blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;name&quot; formatter=&quot;com.acme.MyCellFormatter&quot;/&gt;</pre></blockquote>

<h3><a name="Member_formatter">Member formatter</a></h3>

<p>A member formatter modifies the behavior of <code>
<a href="api/mondrian/olap/Member.html#getCaption()">
Member.getCaption()</a></code>. The class must implement the
<code><a href="api/mondrian/olap/MemberFormatter.html">mondrian.olap.MemberFormatter</a></code> 
interface, and is specified like this:</p><blockquote>
  <pre>&lt;<a href="#XML_Level">Level</a> column=&quot;column&quot; name=&quot;name&quot; formatter=&quot;com.acme.MyMemberFormatter&quot;/&gt;</pre></blockquote>

<h3><a name="Property_formatter">Property formatter</a></h3>

<p>A property formatter modifies the behavior of <code>
<a href="api/mondrian/olap/Member.html#getPropertyFormattedValue(java.lang.String)">
Property.getPropertyFormattedValue()</a></code>. The class must implement the
<code><a href="api/mondrian/olap/PropertyFormatter.html">
mondrian.olap.PropertyFormatter</a></code> interface, and is specified like 
this:</p>
<blockquote>
  <pre>
&lt;<a href="#XML_Level">Level</a> name=&quot;MyLevel&quot; column=&quot;LevelColumn&quot; uniqueMembers=&quot;true&quot;/&gt;
  &lt;<a href="#XML_Property">Property</a> name=&quot;MyProp&quot; column=&quot;PropColumn&quot; formatter=&quot;com.acme.MyPropertyFormatter&quot;/&gt;
&lt;<a href="#XML_Level">Level</a>/&gt;</pre>
</blockquote>

<h3><a name="Schema_processor">Schema processor</a></h3>

<p>A schema processor implements the 
<code><a href="api/mondrian/olap/DynamicSchemaProcessor.html">mondrian.rolap.DynamicSchemaProcessor</a></code> interface. 
It is specified as part of the connection string, like this:</p>

<blockquote>

	<p><code>Jdbc=jdbc:odbc:MondrianFoodMart; JdbcUser=ziggy; JdbcPassword=stardust; 
	DynamicSchemaProcessor=com.acme.MySchemaProcessor</code></p>
</blockquote>

<p>The effect is that when reading the contents of the schema from a URL, 
Mondrian turns to the schema processor rather than Java's default URL handler. 
This gives the schema reader the opportunity to run a schema through a filter, 
or even generate an entire schema on the fly.</p>

<p>Dynamic schemas are a very powerful construct. As we shall see, an important 
application for them is <a href="#I18n">internationalization</a>.</p>
</DOC>

<h2><a name="I18n">Internationalization</a></h2>

<p>An internationalized Mondrian application would have a schema for each 
language, where the caption of each object appears in the local language. For 
example, the <code>[Product]</code> dimension would have the caption &quot;Product&quot; 
in English and &quot;Produit&quot; in French.</p>

<p>It is unwise to translate the actual names of the schema objects, because 
then the MDX statements would need to be changed also. All that you need to 
change is the caption. Every schema object (schema, cube, dimension, level, 
measure) has a caption attribute, and user interfaces such as JPivot display the 
caption rather than the real name. Additionally:
</p>
<ul><li>A hierarchy can have an <code>allMemberCaption</code> attribute as display value of the "All" member.
</li><li>For the schema we can set a display value of the "measures" dimension by the <code>measuresCaption</code> attribute.
</li></ul>

<p>One way to create an internationalized application is to create a copy of the 
schema file for each language, but these are difficult to maintain. A better way 
is to perform dynamic substitution on a single schema file, using a
<a href="#Schema_processor">dynamic schema processor</a>.</p>

<p>First, write your schema using variables as values for <code>caption</code>, <code>allMemberCaption</code> and <code>measuresCaption</code> 
attributes as follows:</p><blockquote>
  <p><code>&lt;<a href="#XML_Schema">Schema</a> measuresCaption=&quot;${MEASURESCAPTION}&quot;&gt;<br>
	&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot; caption=&quot;${GENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Genders&quot; primaryKey=&quot;customer_id&quot; allMemberCaption=&quot;${ALLGENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot; caption=&quot;${GENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot; caption=&quot;${UNITSALES}&quot;&gt;</code></p></blockquote>

<p>(Note that because the <code>[Gender]</code> hierarchy has no <code>caption</code> defined, 
it inherits the <code>caption</code> attribute from its parent, the <code>
[Gender]</code> dimension.)</p>

<p>Next, create a class which implements the
<code><a href="api/mondrian/olap/DynamicSchemaProcessor.html">DynamicSchemaProcessor</a></code> 
interface and whose <code>
<a href="api/mondrian/rolap/DynamicSchemaProcessor.html#processSchema(java.net.URL)">
processSchema(URL)</a></code> method performs JSTL-like variable substitution.</p>

<p>Put this class on the classpath, and include the name of your schema 
processor class in the connect string you use to connect to Mondrian.</p>

<h2><a name="Aggregate_tables">Aggregate tables</a></h2>

<p>Aggregate tables are a way to improve Mondrian's performance when the fact 
table contains a huge number of rows: a million or more. An aggregate table is 
essentially a pre-computed summary of the data in the fact table.</p>

<p>Let's look at 
a simple aggregate table.</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggName">AggName</a> name=&quot;agg_c_special_sales_fact_1997&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggFactCount">AggFactCount</a> 
	column=&quot;FACT_COUNT&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Store Cost]&quot; 
	column=&quot;STORE_COST_SUM&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Store Sales]&quot; 
	column=&quot;STORE_SALES_SUM&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Product].[Product 
	Family]&quot; column=&quot;PRODUCT_FAMILY&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Quarter]&quot; column=&quot;TIME_QUARTER&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Year]&quot; column=&quot;TIME_YEAR&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Quarter]&quot; column=&quot;TIME_QUARTER&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Month]&quot; column=&quot;TIME_MONTH&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_AggName">AggName</a>&gt;<br>
&nbsp; &lt;/<a href="#XML_Table">Table</a>&gt;<br>
	<br>
&nbsp; &lt;!-- Rest of the cube definition --&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>

<p>The <code>&lt;<a href="#XML_AggForeignKey">AggForeignKey</a>&gt;</code> element, 
not shown here, allows you to reference a dimension table directly, without 
including its columns in the aggregate table. It is described in the
<a href="aggregate_tables.html#Another_aggregate_table">aggregate tables guide</a>.</p>

<p>In practice, a cube which is based upon a very large fact table may have 
several aggregate tables. It is inconvenient to declare each aggregate table 
explicitly in the schema XML file, and luckily there is a better way. In the 
following example, Mondrian locates aggregate tables by pattern-matching.</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggPattern">AggPattern</a> pattern=&quot;agg_.*_sales_fact_1997&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggExclude">AggExclude</a> name=&quot;agg_c_14_sales_fact_1997&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggExclude">AggExclude</a> name=&quot;agg_lc_100_sales_fact_1997&quot;/&gt;<br>
&nbsp; &lt;/<a href="#XML_Table">Table</a>&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>

<p>It tells Mondrian to treat all tables which match the pattern <code>&quot;agg_.*_sales_fact_1997&quot;</code> 
as aggregate tables, except <code>&quot;agg_c_14_sales_fact_1997&quot;</code> and <code>
&quot;agg_lc_100_sales_fact_1997&quot;</code>. Mondrian uses rules to deduce the roles of 
the columns in those tables, so it's important to adhere to strict naming 
conventions. The naming conventions are described in the
<a href="aggregate_tables.html#Recognizing_aggregates">aggregate tables guide</a>.</p>

<p>The performance guide has advice on 
<a href="optimizing_performance.html#Choosing_aggregate_tables">choosing aggregate tables</a>.</p>

<h2><a name="Access_control">Access-control</a></h2>

<p>OK, so now you've got all this great data, but you don't everyone to be able to read all
of it. To solve this, you can define an access-control profile, called a <dfn>Role</dfn>, as part of the
schema, and set this role when establishing a connection.</p>

<h3><a name="Defining_roles">Defining a role</a></h3>

<p>Roles are defined by <code><a href="#XML_Role">&lt;Role&gt;</a></code> elements,
which occur as direct children of the <code><a href="#XML_Schema">&lt;Schema&gt;</a></code>
element, after the last <code><a href="#XML_Cube">&lt;Cube&gt;</a></code>. Here is an example of a role:</p><blockquote>
  <p><code>&lt;<a href="#XML_Role">Role</a> name=&quot;California manager&quot;&gt;<br>
	&nbsp; &lt;<a href="#XML_SchemaGrant">SchemaGrant</a> access=&quot;none&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_CubeGrant">CubeGrant</a> cube=&quot;Sales&quot; access=&quot;all&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Store]&quot; access=&quot;custom&quot; topLevel=&quot;[Store].[Store Country]&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Store].[USA].[CA]&quot; access=&quot;all&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Store].[USA].[CA].[Los Angeles]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_HierarchyGrant">HierarchyGrant</a>&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Customers]&quot; access=&quot;custom&quot; topLevel=&quot;[Customers].[State Province]&quot; bottomLevel=&quot;[Customers].[City]&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Customers].[USA].[CA]&quot; access=&quot;all&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Customers].[USA].[CA].[Los Angeles]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_HierarchyGrant">HierarchyGrant</a>&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Gender]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_CubeGrant">CubeGrant</a>&gt;<br>
	&nbsp; &lt;/<a href="#XML_SchemaGrant">SchemaGrant</a>&gt;<br>
	&lt;/<a href="#XML_Role">Role</a>&gt;</code></p></blockquote>

<p>A <code><a href="#XML_SchemaGrant">&lt;SchemaGrant&gt;</a></code> defines the default access for
objects in a schema. The <code>access</code> attribute can be &quot;all&quot; or &quot;none&quot;;
this access can be overridden for specific objects. In this case, because
<code>access=&quot;none&quot;</code>, a user would only be able to browse the &quot;Sales&quot; cube,
because it is explicitly granted.</p>

<p>A <code><a href="#XML_CubeGrant">&lt;CubeGrant&gt;</a></code> defines the access to
a particular cube. As for <code><a href="#XML_SchemaGrant">&lt;SchemaGrant&gt;</a></code>, the access attribute can be &quot;all&quot; or &quot;none&quot;, and can
be overridden for specific sub-objects in the cube.</p>

<p>A <code><a href="#XML_HierarchyGrant">&lt;HierarchyGrant&gt;</a></code> defines
access to a hierarchy. The access attribute can be &quot;all&quot;, meaning all members
are visible; &quot;none&quot;, meaning the hierarchy's very existence is hidden from the
user; and &quot;custom&quot;. With custom access, you can use the <code>topLevel</code>
attribute to define the top level which is visible (preventing users from seeing
too much of the 'big picture', such as viewing revenues rolled up to the <code>
Store Country</code> level); or use the <code>bottomLevel</code> attribute to
define the bottom level which is visible (here, preventing users from invading
looking at individual customers' details); or control which sets of members the
user can see, by defining nested <a href="#XML_MemberGrant">&lt;MemberGrant&gt;</a>
elements.</p>

<p>You can only define a <code><a href="#XML_MemberGrant">&lt;MemberGrant&gt;</a></code>
element if its enclosing <code><a href="#XML_HierarchyGrant">&lt;HierarchyGrant&gt;</a></code>
has <code>access=&quot;custom&quot;</code>. Member grants give (or remove) access to a
given member, and all of its children. Here are the rules:</p><ol>
  <li><b>Members inherit access from their parents</b>. If you deny access to
  California, you won't be able to see San Francisco.</li><li><b>Grants are order-dependent</b>. If you grant access to USA, then deny
  access to Oregon, then you won't be able to see Oregon, or Portland. But if
  you were to deny access to Oregon, then grant access to USA, you can
  effectively see everything.</li><li><b>A member is visible if any of its children are visible</b>. Suppose you
  deny access to USA, then grant access to California. You will be able to see
  USA, and California, but none of the other states. The totals against USA will
  still reflect all states, however.</li><li><b>Member grants don't override the hierarchy grant's top- and
  bottom-levels</b>. If you set <code>topLevel=&quot;[Store].[Store State]&quot;</code>,
  and grant access to California, you won't be able to see USA.</li></ol>

<p>In the example, the user will have access to California, and all of the
cities in California except Los Angeles. They will be able to see USA (because
its child, California, is visible), but no other nations, and not All Stores
(because it is above the top level, <code>Store Country</code>).</p>

<h3><a name="Setting_a_connections_role">Setting a connection's role</a></h3>

<p>A role only has effect when it is associated with a connection. By default,
connections have a role which gives them access to every
cube in that connection's schema.</p>

<p>Most databases associate roles (or 'groups') with users, and automatically
assign them when users log in. However, Mondrian doesn't have the notion of
users, so you have to establish the role in a different way. There are two ways
of doing this:</p><ol>
  <li><b>In the connect string</b>. If you specify the <code>Role</code> keyword
  in the connect string, the connection will adopt that role. See
  <a href="api/mondrian/olap/DriverManager.html">
  class DriverManager</a> for examples of connect string syntax.</li><li><b>Programmatically</b>. Once your application has established a
  connection, call the method
  <a href="api/mondrian/olap/Connection.html#setRole(mondrian.olap.Role)">
  Connection.setRole(Role)</a>. You can create a Role programmatically (see
  <a href="api/mondrian/olap/Role.html">class
  Role</a> for more details), or look
  one up using the method
  <a href="api/mondrian/olap/Schema.html#lookupRole(java.lang.String)">
  Schema.lookupRole(String)</a>.</li></ol>

<h2><a name="Appendix_A_XML_elements">Appendix A: XML elements</a></h2><table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="AutoNumber2">
  <tr>
    <th>Element</th>
    <th>Description</th></tr><tr>
    <td>&nbsp;</td><td>&nbsp;</td></tr><tr>
    <td><code>&lt;<a name="XML_Schema" href="xml_schema.html#Schema">Schema</a>&gt;</code></td>
    <td>Collection of Cubes, Virtual cubes,  Shared dimensions, and Roles.</td></tr>
  <tr>
    <td colspan="2"><i><br>
	Logical elements</i></td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Cube" href="xml_schema.html#Cube">Cube</a>&gt;</code></td>
    <td>A collection of dimensions and measures, all centered on a fact table.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_VirtualCube" href="xml_schema.html#VirtualCube">VirtualCube</a>&gt;</code></td>
    <td>A cube defined by combining the dimensions and measures of one or more
    cubes.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Dimension" href="xml_schema.html#Dimension">Dimension</a>&gt;</code></td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_DimensionUsage" href="xml_schema.html#DimensionUsage">DimensionUsage</a>&gt;</code></td>
    <td>Usage of a shared dimension by a cube.</td></tr>
  <tr>
    <td><code>&lt;<a name="XML_Hierarchy" href="xml_schema.html#Hierarchy">Hierarchy</a>&gt;</code></td>
    <td>Hierarchy.</td>
  </tr>
  <tr>
    <td colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Level" href="xml_schema.html#Level">Level</a>&gt;</code></td>
    <td>Level of a hierarchy.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Property" href="xml_schema.html#Property">Property</a>&gt;</code></td>
    <td>Member property. The definition is against 
	a hierarchy or level, but the
    property will be available to all members.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Measure" href="xml_schema.html#Measure">Measure</a>&gt;</code></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_CalculatedMember" href="xml_schema.html#CalculatedMember">CalculatedMember</a>&gt;</code></td>
    <td>A member whose value is derived using a formula, defined as part of a
    cube.</td>
	</tr>
  <tr>
    <td><code>&lt;<a name="XML_NamedSet"  href="xml_schema.html#NamedSet">NamedSet</a>&gt;</code></td>
    <td>A set whose value is derived using a formula, defined as part of a
    cube.</td>
  </tr>
  <tr>
    <td colspan="2"><i><br>
	Physical elements</i></td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Table" href="xml_schema.html#Table">Table</a>&gt;</code></td>
    <td>Fact or dimension table.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_View" href="xml_schema.html#View">View</a>&gt;</code></td>
    <td>Defines a 'table' using a SQL query, which can have
    different variants for different underlying databases.</td></tr>
  <tr>
    <td><code>&lt;<a name="XML_Join" href="xml_schema.html#Join">Join</a>&gt;</code></td>
    <td>Defines a 'table' by joining a set of queries.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Closure" href="xml_schema.html#Closure">Closure</a>&gt;</code></td>
    <td>Maps a parent-child hierarchy onto a closure table.</td>
  </tr>
  <tr>
    <td colspan="2"><i><br>
	Aggregate Tables</i></td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggExclude" href="xml_schema.html#AggExclude">AggExclude</a>&gt;</code></td>
    <td>Exclude a candidate aggregate table by name or pattern matching.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggName" href="xml_schema.html#AggName">AggName</a>&gt;</code></td>
    <td>Declares an aggregate table to be matched by name.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggPattern" href="xml_schema.html#AggPattern">AggPattern</a>&gt;</code></td>
    <td>Declares a set of aggregate tables by regular expression pattern.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggFactCount" href="xml_schema.html#AggFactCount">AggFactCount</a>&gt;</code></td>
    <td>Specifies name of the column in the candidate aggregate table which 
	contains the number of fact table rows.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggIgnoreColumn" href="xml_schema.html#AggIgnoreColumn">AggIgnoreColumn</a>&gt;</code></td>
    <td>Tells Mondrian to ignore a column in an aggregate table.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggForeignKey" href="xml_schema.html#AggForeignKey">AggForeignKey</a>&gt;</code></td>
    <td>Maps foreign key in the fact table to a foreign key column in the candidate aggregate table.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggMeasure" href="xml_schema.html#AggMeasure">AggMeasure</a>&gt;</code></td>
    <td>Maps a measure to a column in the candidate aggregate table.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_AggLevel" href="xml_schema.html#AggLevel">AggLevel</a>&gt;</code></td>
    <td>Maps a level to a column in the candidate aggregate table.</td>
  </tr>
  <tr>
    <td colspan="2"><i><br>
	Access control</i></td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#Role" name="XML_Role">Role</a>&gt;</code></td>
    <td>An access-control profile.</td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#SchemaGrant" name="XML_SchemaGrant">SchemaGrant</a>&gt;</code></td>
    <td>A set of rights to a schema.</td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#CubeGrant" name="XML_CubeGrant">CubeGrant</a>&gt;</code></td>
    <td>A set of rights to a cube.</td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#HierarchyGrant" name="XML_HierarchyGrant">HierarchyGrant</a>&gt;</code></td>
    <td>A set of rights to a hierarchy and levels within that hierarchy.</td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#MemberGrant" name="XML_MemberGrant">MemberGrant</a>&gt;</code></td>
    <td>A set of rights to a member and its children.</td>
  </tr>
  <tr>
    <td colspan="2"><i><br>
	Extensions</i></td>
  </tr>
	<tr>
    <td><code>&lt;<a href="xml_schema.html#UserDefinedFunction" name="XML_UserDefinedFunction">UserDefinedFunction</a>&gt;</code></td>
    <td>Imports a user-defined function.</td>
  </tr>
  <tr>
    <td colspan="2"><i><br>
	Miscellaneous</i></td>
  </tr>
  <tr>
    <td><code>&lt;<a href="xml_schema.html#Parameter" name="XML_Parameter">Parameter</a>&gt;</code></td>
    <td>Part of the definition of a Hierarchy; passed to a MemberReader, if 
	present.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_CalculatedMemberProperty" href="xml_schema.html#MemberProperty">CalculatedMemberProperty</a>&gt;</code></td>
    <td>Property of a calculated member.</td></tr>
  <tr>
    <td><code>&lt;<a name="XML_Formula" href="xml_schema.html#Formula">Formula</a>&gt;</code></td>
    <td>Holds the formula text within a NamedSet or CalculatedMember.</td>
  </tr>
</table>

<hr>

<table border="0" class="clsStd" width="100%" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
  <tr>
    <td class="content">
      <a target="_top" href="index.html">Home</a> |
      <a target="_top" href="schema.html">No frames</a> | This file is<i>
      <a href="http://mondrian.sourceforge.net/schema.html">$Id$
      </a></i> (<a href="http://perforce.eigenbase.org:8080/open/mondrian/doc/schema.html?ac=22">log</a>)</td><td align="right">
      <a href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=35302&type=1" width="88" height="31" border="0" alt="SourceForge.net Logo">
      </a>
    </td>
  </tr>
</table>

</body>
</html>
