<html>
<!--
  == $Id$
  == This software is subject to the terms of the Common Public License
  == Agreement, available at the following URL:
  == http://www.opensource.org/licenses/cpl.html.
  == Copyright (C) 2001-2005 Kana Software, Inc. and others.
  == All Rights Reserved.
  == You must accept the terms of that agreement to use this software.
  == jhyde, 24 September, 2002
  -->

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>How to design a mondrian schema</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css" />
</head>

<body>
<h1>How to design a Mondrian schema</h1>
<p>Julian Hyde; last updated April, 2005.</p>
<h2>Contents</h2>
<ol>
  <li><a href="#What_is_a_schema">What is a schema?</a></li>
  <li><a href="#Schema_files">Schema files</a></li>
  <li><a href="#Cubes_and_dimensions">Logical model</a><ol>
  <li><a href="#Cube">Cube</a></li>
    <li><a href="#Measures">Measures</a></li>
    <li><a href="#Calculated_members">Calculated members</a></li>
    <li><a href="#Dimensions,_Hierarchies,_Levels">Dimensions, Hierarchies,
    Levels</a></li>
</ol>
    </li>
  <li><a href="#Star_schemas">Star and snowflake schemas</a>
  <ol>
      <li><a href="#Shared_dimensions">Shared dimensions</a></li>
      <li><a href="#Join_optimization">Join optimization</a></li>
  </ol></li>
  <li><a href="#Advanced_logical_constructs">Advanced logical constructs</a>
  <ol>
      <li><a href="#Virtual_cubes">Virtual cubes</a></li>
      <li><a href="#Shared_dimensions">Shared dimensions</a></li>
      <li><a href="#Parent_child_hierarchies">Parent-child hierarchies</a></li>
      <li><a href="#Member_properties">Member properties</a></li>
  </ol></li>
  <li><a href="#Advanced_physical_constructs">Advanced physical constructs</a>
  <ol>
      <li><a href="#Member_readers">Member readers</a></li>
      <li><a href="#Cell_readers">Cell readers</a></li>
      <li><a href="#Cell_formatter">Cell formatter</a></li>
      <li><a href="#Member_formatter">Member formatter</a></li>
      <li><a href="#I18n">Internationalization</a></li>
  </ol></li>
  <li><a href="#Advanced_aggregate_tables">Advanced aggregate tables</a>
  <ol>
      <li><a href="#What_are_aggregates">What are aggregate tables</a></li>
      <li><a href="#Building_aggregates">Building aggregate tables</a></li>
      <li><a href="#Recognizing_aggregates">Recognizing aggregate tables</a>
      <ol>
        <li><a href="#Recognizing_default">Default</a></li>
        <li><a href="#Recognizing_explicit">Explicit</a></li>
      </ol>
      </li>
      <li><a href="#Aggregate_properties">Aggregate properties</a>
  </ol></li>

  <li><a href="#Access_control">Access-control</a>
  <ol>
    <li><a href="#Defining_roles">Defining a role</a></li>
    <li><a href="#Setting_a_connections_role">Setting a connection's role</a></li>
  </ol></li>
  <li><a href="#Appendix_A_XML_elements">Appendix A: XML elements</a></li>
</ol>
<h2><a name="What_is_a_schema">What is a schema?</a></h2>
<p>A schema defines a multi-dimensional database. It contains a logical model,
consisting of cubes, hierarchies, and members, and a mapping of this model onto
a physical model.</p>
<p>The logical model consists of the constructs used to write queries in MDX
language: cubes, dimensions, hierarchies, levels, and members.</p>
<p>The physical model is the source of the data which is presented through the
logical model. It is typically a star schema, which is a set of tables in a
relational database; later, we shall see examples of other kinds of mappings.</p>
<h2><a name="Schema_files">Schema files</a></h2>
<p>Mondrian schemas are represented in an XML file. An example schema,
containing almost all of the constructs we discuss here, is supplied as <code>
<a href="../demo/FoodMart.xml">demo/FoodMart.xml</a></code>. The dataset to 
populate this schema is available as part of the
<a href="install.html#3_Set_up_test_data">mondrian distribution</a>.</p>
<p>Currently, the only way to create a schema is to edit a schema XML file in a
text editor. The XML syntax is not too complicated, so this is not as difficult
as it sounds, particularly if you use the FoodMart schema as a guiding example.
We are also developing a graphical workbench (written in Swing) to create and modify
schemas.</p>
<h2><a name="Cubes_and_dimensions">Logical model</a></h2>
<p>The most important components of a schema are cubes, measures, and
dimensions:</p>
<ul>
  <li>A <dfn>cube</dfn> is a collection of
  dimensions and measures in a particular subject area. </li>
  <li>A <dfn>measure</dfn> is a quantity that you are
interested in measuring, for example, unit sales of a product, or cost price of
inventory items.</li>
  <li>A <dfn>dimension</dfn> is an attribute, or set of
attributes, by which you can divide measures into sub-categories. For example,
you might wish to break down product sales by their color, the gender of the
customer, and the store in which the product was sold; color, gender, and store
are all dimensions.</li>
</ul>
<p>Let's look at the XML definition of a simple schema.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Schema">Schema</a>&gt;
  &lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
    &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot;&gt;
      &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Genders&quot; primaryKey=&quot;customer_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;customer&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot;/&gt;
      &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
    &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Time&quot; foreignKey=&quot;time_id&quot;&gt;
      &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_day&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
            uniqueMembers=&quot;true&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Quarter&quot; column=&quot;quarter&quot;
            uniqueMembers=&quot;false&quot;/&gt;
        &lt;<a href="#XML_Level">Level</a> name=&quot;Month&quot; column=&quot;month_of_year&quot; type=&quot;Numeric&quot;
            uniqueMembers=&quot;false&quot;/&gt;
      &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
    &lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot;
        aggregator=&quot;sum&quot; formatString=&quot;#,###&quot;/&gt;
    &lt;<a href="#XML_Measure">Measure</a> name=&quot;Store Sales&quot; column=&quot;store_sales&quot;
        aggregator=&quot;sum&quot; formatString=&quot;#,###.##&quot;/&gt;
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a> name=&quot;Profit&quot; dimension=&quot;Measures&quot;
        formula=&quot;[Measures].[Store Sales]-[Measures].[Store Cost]&quot;&gt;
      &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;
  &lt;/<a href="#XML_Cube">Cube</a>&gt;
&lt;/<a href="#XML_Schema">Schema</a>&gt;</pre>
</blockquote>
<p>This schema contains a single cube, called &quot;Sales&quot;. The Sales cube has two
dimensions, &quot;Time&quot;, and &quot;Gender&quot;, and two measures, &quot;Unit Sales&quot; and &quot;Store
Sales&quot;.</p>
<p>We can write an MDX query on this schema:</p>
<blockquote>
<p><code>SELECT {[Measures].[Unit Sales], [Measures].[Store Sales]} ON COLUMNS,<br>
&nbsp; {[Time].[1997].[Q1].descendants} ON ROWS<br>
FROM [Sales]<br>
WHERE [Gender].[F]</code></p>
</blockquote>
<p>This query refers to the Sales cube (<code>[Sales]</code>), each of the
dimensions <code>[Measures]</code>, <code>[Time]</code>, <code>[Gender</code>],
and various members of those dimensions. The results are as follows:</p>
<blockquote>
  <table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="AutoNumber1">
    <tr>
      <th align="left">[Time]</th>
      <th>[Measures].[Unit Sales]</th>
      <th>[Measures].[Store Sales]</th>
    </tr>
    <tr>
      <th align="left">[1997].[Q1]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Jan]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Feb]</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th align="left">[1997].[Q1].[Mar]</th>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>
</blockquote>
<p>Now let's look at the schema definition in more detail.</p>
<h3><a name="Cube">Cube</a></h3>
<p>A cube (see <code><a href="#XML_Cube">&lt;Cube&gt;</a></code>) is a named collection of measures and dimensions. The one thing the measures and
dimensions have in common is the fact table, here <code>&quot;sales_fact_1997&quot;</code>.
As we shall see, the fact table holds the columns from which measures are
calculated, and contains references to the tables which hold the dimensions.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
  ...
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>The fact table is defined using the <a href="#XML_Table">&lt;Table&gt;</a> element.
If the fact table is not in the default schema, you can provide an explicit
schema using the &quot;schema&quot; attribute, for example</p>
<blockquote>
  <pre>&lt;<a href="#XML_Table">Table</a> schema=&quot;foodmart&quot; name=&quot;sales_fact_1997&quot;/&gt;</pre>
</blockquote>
<p>You can also use the <code><a href="#XML_View">&lt;View&gt;</a></code> and <code>
<a href="#XML_Join">&lt;Join&gt;</a></code> constructs to build more complicated SQL
statements.</p>
<h3><a name="Measures">Measures</a></h3>
<p>The Sales cube defines two measures, &quot;Unit Sales&quot; and &quot;Store Sales&quot;.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot;
    aggregator=&quot;sum&quot; formatString=&quot;#,###&quot;/&gt;
&lt;<a href="#XML_Measure">Measure</a> name=&quot;Store Sales&quot; column=&quot;store_sales&quot;
    aggregator=&quot;sum&quot; formatString=&quot;#,###.00&quot;/&gt;</pre>
</blockquote>
<p>Each measure (see <a href="#XML_Measure">&lt;Measure&gt;</a>) has a name,
a column in the fact table, and an <code>aggregator</code>. The aggregator is usually &quot;sum&quot;,
but &quot;count&quot;, &quot;mix&quot;, &quot;max&quot;, &quot;avg&quot;, and &quot;distinct count&quot; are also allowed;
&quot;distinct count&quot; has some limitations if your cube contains a
<a href="#Parent_child_hierarchies">parent-child hierarchy</a>.</p>

<p>An optional <code>formatString</code> attribute specifies how the value is to
be printed. Here, we have chosen to output unit sales with no decimal places
(since it is an integer), and store sales with two decimal places (since it is a
currency value). The ',' and '.' symbols are locale-sensitive, so if you were
running in Italian, store sales might appear as &quot;48.123,45&quot;. You can achieve
even more wild effects using <a href="#Format_strings">advanced format strings</a>.</p>
<p>A measure can have a caption attribute to be returned by getCaption() instead of the name.
Defining a specific caption does make sense if special letters (e.g. &#931; or &#928;) are to be displayed.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;Sum X&quot; column=&quot;sum_x&quot; aggregator=&quot;sum&quot; caption=&quot;&amp;#931; X&quot;/&gt;
</blockquote>
<p>Rather than coming from a column, a measure can use a
<a href="#Cell_readers">cell reader</a>.</p>
<p>In order to provide a specific formatting of the cell values, a measure can use a
<a href="#Cell_formatter">cell formatter</a>.</p>

<h3><a name="Calculated_members">Calculated members</a></h3>

<p>Suppose you want to create a measure whose value comes not from a
column of the fact table, but from an MDX formula. One way to do this is to use
a WITH MEMBER clause, like this:</p>

<blockquote>

    <p><code>WITH MEMBER [Measures].[Profit] AS '[Measures].[Store
    Sales]-[Measures].[Store Cost]',<br>
&nbsp;&nbsp; FORMAT_STRING = '$#,###'<br>
    SELECT {[Measures].[Store Sales], [Measures].[Profit]} ON COLUMNS,<br>
&nbsp; {[Product].Children} ON ROWS<br>
    FROM [Sales]<br>
    WHERE [Time].[1997]</code></p>
</blockquote>
<p>But rather than including this clause in every MDX query of your application,
you can define the member in your schema, as part of your cube definition:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_CalculatedMember">CalculatedMember</a> name=&quot;Profit&quot; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; formula=&quot;[Measures].[Store Sales]-[Measures].[Store Cost]&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;<br>
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code></p>
</blockquote>

<p>Note that the <code>&lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a>&gt;</code>
(not <code>&lt;<a href="#XML_Property">Property</a>&gt;</code>) element corresponds
to the <code>FORMAT_STRING = '$#,###'</code> fragment of the MDX statement. You
can define other properties here too, but <code>FORMAT_STRING</code> is by far
the most useful in practice.</p>

<p>The FORMAT_STRING property value can also be evaluated using an expression. When
formatting a particular cell, first the expression is evaluated to yield a
format string, then the format string is applied to the cell value. Here is the
same property with a conditional format string:</p>

<blockquote>

    <p><code>&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a>
    name=&quot;FORMAT_STRING&quot; expression=&quot;Iif(Value &lt; 0, '|($#,##0.00)|style=red',
    '|$#,##0.00|style=green')&quot;/&gt;</code></p>
</blockquote>

<p>For more details about format strings, see the
<a href="mdx.html#Format_strings">MDX specification</a>.</p>

<p>You can make a calculated member or a measure invisible. If you specify <code>
visible=&quot;false&quot;</code> (the default is &quot;true&quot;) in the <code>&lt;<a href="#XML_Measure">Measure</a>&gt;
or &lt;<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code> element,
user-interfaces such as JPivot will notice this property and hide the member.
This is useful if you want to perform calculations in a number of steps, and
hide intermediate steps from end-users. For example, here only &quot;Margin per Sqft&quot;
is visible, and its factors &quot;Store Cost&quot;, &quot;Margin&quot; and &quot;Store Sqft&quot; are hidden:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_Measure">Measure</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Store Cost&quot;<br>
&nbsp;&nbsp;&nbsp; column=&quot;store_cost&quot;<br>
&nbsp;&nbsp;&nbsp; aggregator=&quot;sum&quot;<br>
&nbsp;&nbsp;&nbsp; formatString=&quot;#,###.00&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;/&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Margin&quot; <br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot; <br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;<br>
&nbsp;&nbsp;&nbsp; formula=&quot;([Measures].[Store Sales] - [Measures].[Store Cost])
    / [Measures].[Store Cost]&quot;/&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Store Sqft&quot; <br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;false&quot;<br>
&nbsp;&nbsp;&nbsp; formula='[Store].Properties(&quot;Sqft&quot;)'/&gt;<br>
    &lt;<a href="#XML_CalculatedMember">CalculatedMember</a><br>
&nbsp;&nbsp;&nbsp; name=&quot;Margin per Sqft&quot;<br>
&nbsp;&nbsp;&nbsp; dimension=&quot;Measures&quot;<br>
&nbsp;&nbsp;&nbsp; visible=&quot;true&quot;<br>
&nbsp;&nbsp;&nbsp; formula=&quot;[Measures].[Margin] / [Measures].[Store Cost]&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_CalculatedMemberProperty">CalculatedMemberProperty</a> name=&quot;FORMAT_STRING&quot; value=&quot;$#,##0.00&quot;/&gt;<br>
    &lt;/<a href="#XML_CalculatedMember">CalculatedMember</a>&gt;</code></p>
</blockquote>

<h3><a name="Dimensions,_Hierarchies,_Levels">Dimensions, Hierarchies, Levels</a></h3>
<p>The Gender dimension consists of a single hierarchy, which has just one
level.</p>
<blockquote>
  <pre>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot;&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;customer_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;customer&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</pre>
</blockquote>
<p>For any given sale, the gender dimension is the gender of the customer who
made that purchase. This is expressed by joining from the fact table
&quot;sales_fact_1997.customer_id&quot; to the dimension table &quot;customer.customer_id&quot;.</p>
<p>The &quot;gender&quot; column contains two values, 'F' and 'M', so the Gender dimension
contains the members <code>[Gender].[F]</code> and <code>[Gender].[M]</code>. Because <code>hasAll=&quot;true&quot;</code>, the system generates a special level 
called '<code>(All)</code>', containing a single member called <code>[Gender].[All Gender]</code>. 
You can override these names using the <code>allLevelName</code> and <code>
allMemberName</code> attributes of the <code>&lt;<a href="#XML_Hierarchy">Hierarchy</a>&gt; 
element</code>.</p>

<p>By default, every hierarchy contains a top level called '(All)', which 
contains a single member. If the <code>&lt;Hierarchy&gt;</code> element has <code>
hasAll=&quot;false&quot;</code>, the 'all' level is suppressed; the allMemberName and 
allLevelName attributes allow you to suppress the </p>
<p>A dimension can contain more than one hierarchy:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Time&quot; foreignKey=&quot;time_id&quot;&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_day&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;true&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Quarter&quot; column=&quot;quarter&quot;
        uniqueMembers=&quot;false&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Month&quot; column=&quot;month_of_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;false&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;<a href="#XML_Hierarchy">Hierarchy</a> name=&quot;Time Weekly&quot; hasAll=&quot;false&quot; primaryKey=&quot;time_id&quot;&gt;
    &lt;<a href="#XML_Table">Table</a> name=&quot;time_by_week&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Year&quot; column=&quot;the_year&quot; type=&quot;Numeric&quot;
        uniqueMembers=&quot;true&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Week&quot; column=&quot;week&quot;
        uniqueMembers=&quot;false&quot;/&gt;
    &lt;<a href="#XML_Level">Level</a> name=&quot;Day&quot; column=&quot;day_of_week&quot; type=&quot;String&quot;
        uniqueMembers=&quot;false&quot;/&gt;
  &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</pre>
</blockquote>
<p>Notice that the first hierarchy doesn't have a name. By default, a hierarchy
has the same name as its dimension, so the first hierarchy is called &quot;Time&quot;.</p>
<p>These hierarchies don't have much in common &mdash; they don't even have the same
table! &mdash; except that they are joined from the same column in the fact table,
<code>&quot;time_id&quot;</code>. The main reason to put two hierarchies in the same
dimension is because it makes more sense to the end-user: end-users know that it
makes no sense to have the &quot;Time&quot; hierarchy on one axis and the &quot;Time Weekly&quot;
hierarchy on another axis. If two hierarchies are the same dimension, the MDX
language enforces common sense, and does not allow you to use them both in the
same query.</p>
<p>A dimension can live in the fact table:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;
  ...
  &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Payment method&quot;&gt;
    &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot;&gt;
      &lt;<a href="#XML_Level">Level</a> name=&quot;Payment method&quot; column=&quot;payment_method&quot; uniqueMembers=&quot;true&quot;/&gt;
    &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>Each dimension contains a single hierarchy, which is made up of a number levels.</p>

<p>Some more definitions:</p>
<ul>
  <li>A <dfn>member</dfn> is a point within a dimension
determined by a particular set of attribute values. The gender hierarchy has
the two members 'M' and 'F'. 'San Francisco', 'California' and 'USA' are all
members of the store hierarchy.</li>
  <li>A <dfn>hierarchy</dfn> is a set of related
attributes (or <dfn>levels</dfn>) which collectively
form a dimension. For example, the store hierarchy consists of the store name,
city, state, and nation. The hierarchy allows you form intermediate sub-totals:
the sub-total for a state is the sum of the sub-totals of all of the cities in
that state, each of which is the sum of the sub-totals of the stores in that
city.</li>
</ul>
<p>For reasons of uniformity, measures are treated as members of a special
dimension, called 'Measures'.</p>
<p>Most dimensions have just one hierarchy, but occasionally a dimension has
more than one. For example, you might wish to aggregate days from the Time
dimension into months, quarters, and years; or into weeks and years. Both
hierarchies start off with days and end with years, but aggregate using
different paths.</p>
<p>Most hierarchies have an <dfn>all-member</dfn>,
which is parent of all other members of the hierarchy, and thus represents a
grand total. It is typically named 'All <i>something</i>', for example, 'All
stores'.</p>
<p><a href="#Member_properties">Member properties</a> can be assigned to a level's members. The property values are retrieved
 by <code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/Member.html#getPropertyValue(java.lang.String)">getPropertyValue()</a></code>
 or as String by <code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/Member.html#getPropertyFormattedValue(java.lang.String)">getPropertyFormattedValue()</a></code>.
 A formatter class can be defined, which would be used by <code>getPropertyFormattedValue()</code>.</p>
<blockquote>
  <pre>
&lt;<a href="#XML_Level">Level</a> name=&quot;MyLevel&quot; column=&quot;LevelColumn&quot; uniqueMembers=&quot;true&quot;/&gt;
  &lt;<a href="#XML_Property">Property</a> name=&quot;MyProp&quot; column=&quot;PropColumn&quot; formatter=&quot;com.foo.MyPropertyFormatter&quot;/&gt;
&lt;<a href="#XML_Level">Level</a>/&gt;</pre>
</blockquote>
<p>The class &quot;com.foo.MyPropertyFormatter&quot; would have to implement <code>
<a href="http://mondrian.sourceforge.net/api/mondrian/olap/PropertyFormatter.html">
interface mondrian.olap.PropertyFormatter</a></code>.</p>

<p>A member's value to be displayed by getCaption() can be formatted by a
<a href="#Member_formatter">member formatter</a>.</p>

<h2><a name="Star_schemas">Star and snowflake schemas</a></h2>
<p>We saw earlier how to build a cube based upon a fact table, and dimensions in
the fact table (&quot;Payment method&quot;) and in a table joined to the fact table
(&quot;Gender&quot;). This is the most common kind of mapping, and is known as a <dfn>
star schema</dfn>.</p>
<p>But a dimension can be based upon more than one table, provided that there is
a well-defined path to join these tables to the fact table. This kind of
dimension is known as a snowflake, and is defined using the <code>&lt;Join&gt;</code>
operator. For example:</p>
<blockquote>
  <pre>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;
  ...
  &lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Product&quot; foreignKey=&quot;product_id&quot;&gt;
    &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;product_id&quot; primaryKeyTable=&quot;product&quot;&gt;
      &lt;Join leftKey=&quot;product_class_id&quot; rightAlias=&quot;product_class&quot; rightKey=&quot;product_class_id&quot;&gt;
        &lt;<a href="#XML_Table">Table</a> name=&quot;product&quot;/&gt;
        &lt;Join leftKey=&quot;product_type_id&quot; rightKey=&quot;product_type_id&quot;&gt;
          &lt;<a href="#XML_Table">Table</a> name=&quot;product_class&quot;/&gt;
          &lt;<a href="#XML_Table">Table</a> name=&quot;product_type&quot;/&gt;
        &lt;/Join&gt;
      &lt;/Join&gt;
      ...
    &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;
  &lt;/<a href="#XML_Dimension">Dimension</a>&gt;
&lt;/<a href="#XML_Cube">Cube</a>&gt;</pre>
</blockquote>
<p>This defines a <code>&quot;Product&quot;</code> dimension consisting of three tables.
The fact table joins to <code>&quot;product&quot;</code> (via the foreign key <code>&quot;product_id&quot;</code>),
which joins to <code>&quot;product_class&quot;</code> (via the foreign key <code>&quot;product_class_id&quot;</code>),
which joins to <code>&quot;product_type&quot;</code> (via the foreign key <code>&quot;product_type_id&quot;</code>).
We require a <code>&lt;Join&gt;</code> element nested within a <code>&lt;Join&gt;</code>
element because <code>&lt;Join&gt;</code> takes two operands; the operands can be
tables, joins, or even queries.</p>
<p>The arrangement of the tables seems complex, the simple rule of thumb is to
order the tables by the number of rows they contain. The <code>&quot;product&quot;</code>
table has the most rows, so it joins to the fact table and appears first; <code>
&quot;product_class&quot;</code> has fewer rows, and <code>&quot;product_type&quot;</code>, at the
tip of the snowflake, has least of all.</p>
<p>Note that the outer <code>&lt;Join&gt;</code> element has a <code>rightAlias</code>
attribute. This is necessary because the right component of the join (the inner
<code>&lt;Join&gt;</code> element) consists of more than one table. No <code>leftAlias</code>
attribute is necessary in this case, because the leftKey column unambiguously
comes from the <code>&quot;product&quot;</code> table.</p>
<h3><a name="Shared_dimensions">Shared dimensions</a></h3>
<p>When generating the SQL for a join, mondrian needs to know which column to
join to. If you are joining to a join, then you need to tell it which of the
tables in the join that column belongs to (usually it will be the first table in
the join).</p>
<p>Because shared dimensions don't belong to a cube, you have to give them an
explicit table (or other data source). When you use them in a particular cube,
you specify the foreign key. This example shows the <code>Store Type</code>
dimension being joined to the <code>Sales</code> cube using the <code>
sales_fact_1997.store_id</code> foreign key, and to the <code>Warehouse</code>
cube using the <code>warehouse.warehouse_store_id</code> foreign key:</p>
<blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Store Type&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; primaryKey=&quot;store_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;store&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Store Type&quot; column=&quot;store_type&quot; uniqueMembers=&quot;true&quot;/&gt;<br>
&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;<br>
	<br>
	&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;sales_fact_1997&quot;/&gt;<br>
&nbsp; ...<br>
&nbsp; &lt;<a href="#XML_DimensionUsage">DimensionUsage</a> name=&quot;Store Type&quot; source=&quot;Store Type&quot; foreignKey=&quot;store_id&quot;/&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;<br>
	<br>
	&lt;<a href="#XML_Cube">Cube</a> name=&quot;Warehouse&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;warehouse&quot;/&gt;<br>
&nbsp; ...<br>
&nbsp; &lt;<a href="#XML_DimensionUsage">DimensionUsage</a> name=&quot;Store Type&quot; source=&quot;Store Type&quot; foreignKey=&quot;warehouse_store_id&quot;/&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>
<h3><a name="Join_optimization">Join optimization</a></h3>
<p>The table mapping in the schema tells Mondrian how to get the data, but
Mondrian is smart enough not to read the schema literally. It applies a number
of optimizations when generating queries:</p>
<ul>
  <li>If a dimension has a small number of members, Mondrian reads it into a
  cache on first use. See the
  <a href="http://mondrian.sourceforge.net/api/mondrian/olap/MondrianProperties.html#getLargeDimensionThreshold()">
  mondrian.rolap.LargeDimensionThreshold</a> property.</li>
  <li>If a dimension (or, more precisely, the level of the dimension being
  accessed) is in the fact table, Mondrian does not perform a join.</li>
  <li>If two dimensions access the same table via the same join path, Mondrian
  only joins them once. For example, <code>[Gender]</code> and <code>[Age]</code>
  might both be columns in the <code>customers</code> table, joined via <code>
  sales_1997.cust_id = customers.cust_id</code>.</li>
</ul>
<h2><a name="Advanced_logical_constructs">Advanced logical constructs</a></h2>
<h3><a name="Virtual_cubes">Virtual cubes</a></h3>
<p>Defined by the <code><a href="#XML_VirtualCube">&lt;VirtualCube&gt;</a></code> element. (To be continued...)</p>
<h3><a name="Parent_child_hierarchies">Parent-child hierarchies</a></h3>
<p>A conventional hierarchy has a rigid set of levels, and members which adhere
to those levels. For example, in the <code>Product</code> hierarchy, any member of the
<code>Product Name</code> level has a parent in the <code>Brand Name</code> level, which has a parent in
the <code>Product Subcategory</code> level, and so forth. This structure is
sometimes too rigid to model real-world data.</p>
<p>A <dfn>parent-child hierarchy</dfn> has only one level (not counting the special 'all'
level), but any member can have parents in the same level. A classic example is
the reporting structure in the <code>Employees</code> hierarchy:</p>
<blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Employees&quot; foreignKey=&quot;employee_id&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Employees&quot; primaryKey=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;employee&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Employee Id&quot; uniqueMembers=&quot;true&quot; type=&quot;Numeric&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; column=&quot;employee_id&quot; nameColumn=&quot;full_name&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentColumn=&quot;supervisor_id&quot; nullParentValue=&quot;0&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Marital Status&quot; column=&quot;marital_status&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Position Title&quot; column=&quot;position_title&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Gender&quot; column=&quot;gender&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Salary&quot; column=&quot;salary&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Education Level&quot; column=&quot;education_level&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Management Role&quot; column=&quot;management_role&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_Level">Level</a>&gt;<br>
&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code></p>
</blockquote>
<p>The important attributes here are <code>parentColumn</code> and <code>
nullParentValue</code>:</p>
<ul>
  <li>The <code>parentColumn</code> attribute is the name of the column which
  links a member to its parent member; in this case, it is the foreign key
  column which points to an employee's supervisor. The <code>&lt;ParentExpression&gt;</code>
  child element of <code>&lt;Level&gt;</code> is equivalent to the <code>parentColumn</code>
  attribute, but allows you to define an arbitrary SQL expression, just like the
  <code>&lt;Expression&gt;</code> element. The <code>parentColumn</code> attribute (or
  <code>&lt;ParentExpression&gt;</code> element) is the only indication to Mondrian
  that a hierarchy has a parent-child structure.</li>
  <li>The <code>nullParentValue</code> attribute is the value which indicates
  that a member has no parent. The default is <code>nullParentValue=&quot;null&quot;</code>,
  but since many database don't index null values, schema designers sometimes
  use values as the empty string, 0, and -1 instead.</li>
</ul>

<h4>Tuning parent-child hierarchies</h4>

<p>There's one serious problem with the parent-child hierarchy defined above,
and that is the amount of work Mondrian has to do in order to compute
cell-totals. Let's suppose that the employee table contains the following data:</p>

<blockquote>
<table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="table3">
    <tr>
        <th colspan="3">employee</th>
    </tr>
    <tr>
        <th>supervisor_id</th>
        <th>employee_id</th>
        <th>full_name</th>
    </tr>
    <tr>
        <td>null</td>
        <td>1</td>
        <td>Frank</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2</td>
        <td>Bill</td>
    </tr>
    <tr>
        <td>2</td>
        <td>3</td>
        <td>Eric</td>
    </tr>
    <tr>
        <td>1</td>
        <td>4</td>
        <td>Jane</td>
    </tr>
    <tr>
        <td>3</td>
        <td>5</td>
        <td>Mark</td>
    </tr>
    <tr>
        <td>2</td>
        <td>6</td>
        <td>Carla</td>
    </tr>
</table>
</blockquote>

<p>If we want to compute the total salary budget for Bill, we need to add in the
salaries of Eric and Carla (who report to Bill) and Mark (who reports to Eric).
Usually Mondrian generates a SQL <code>GROUP BY</code> statement to compute
these totals, but there is no (generally available) SQL construct which can
traverse hierarchies. So by default, Mondrian generates one SQL statement per
supervisor, to retrieve and total all of that supervisor's direct reports.</p>

<p>This approach has a couple of drawbacks. First, the performance is not very
good if a hierarchy contains more than a hundred members. Second, because Mondrian implements the
&quot;distinct count&quot; aggregator by generating SQL, you
cannot define a &quot;distinct count&quot; member in any cube which contains a parent-child
hierarchy.</p>

<p>How can we solve these problems? The answer is to enhance the data so that Mondrian is able to retrieve the information it needs using standard SQL. Mondrian supports 
a mechanism called a <dfn>closure table</dfn> for 
this purpose.</p>

<p>A closure table is a SQL table which contains a record for every
employee/supervisor relationship, regardless of depth. (In mathematical terms,
this is called the 'reflexive transitive closure' of the employee/supervisor
relationship. The <code>distance</code> column is not strictly required, but it
makes it easier to populate the table.)</p>

<blockquote>
<table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="table3">
    <tr>
        <th colspan="3">employee_closure</th>
    </tr>
    <tr>
        <th width="91">supervisor_id</th>
        <th width="85">employee_id</th>
        <th width="8">distance</th>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">1</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">2</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">3</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">4</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">5</td>
        <td width="8">3</td>
    </tr>
    <tr>
        <td width="91">1</td>
        <td width="85">6</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">2</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">3</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">5</td>
        <td width="8">2</td>
    </tr>
    <tr>
        <td width="91">2</td>
        <td width="85">6</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">3</td>
        <td width="85">3</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">3</td>
        <td width="85">5</td>
        <td width="8">1</td>
    </tr>
    <tr>
        <td width="91">4</td>
        <td width="85">4</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">5</td>
        <td width="85">5</td>
        <td width="8">0</td>
    </tr>
    <tr>
        <td width="91">6</td>
        <td width="85">6</td>
        <td width="8">0</td>
    </tr>
    </table>
</blockquote>

<p>In the catalog XML, the <code>&lt;<a href="#XML_Closure">Closure</a>&gt;</code>
element maps the level onto a <code>&lt;<a href="#XML_Table">Table</a>&gt;</code>:</p>

<blockquote>

    <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Employees&quot; foreignKey=&quot;employee_id&quot;&gt;<br>
&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Employees&quot; primaryKey=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a> name=&quot;employee&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Employee Id&quot; uniqueMembers=&quot;true&quot; type=&quot;Numeric&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; column=&quot;employee_id&quot; nameColumn=&quot;full_name&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentColumn=&quot;supervisor_id&quot; nullParentValue=&quot;0&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Closure">Closure</a> parentColumn=&quot;supervisor_id&quot; childColumn=&quot;employee_id&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Table">Table</a>
    name=&quot;employee_closure&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_Closure">Closure</a>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Marital Status&quot; column=&quot;marital_status&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Position Title&quot; column=&quot;position_title&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Gender&quot; column=&quot;gender&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Salary&quot; column=&quot;salary&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Education Level&quot; column=&quot;education_level&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Property">Property</a> name=&quot;Management Role&quot; column=&quot;management_role&quot;/&gt;<br>
&nbsp;&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
    &lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code></p>
</blockquote>

<p>This table allows totals to be evaluated in pure SQL. Even though
this introduces an extra table into the query, database optimizers are very good at
handling joins. I recommend that you declare both <code>supervisor_id</code>
and <code>employee_id</code> NOT NULL, and index them as follows:</p>

<blockquote>

    <p><code>CREATE UNIQUE INDEX employee_closure_pk ON employee_closure (<br>
&nbsp;&nbsp; supervisor_id,<br>
&nbsp;&nbsp; employee_id<br>
    );<br>
    CREATE INDEX employee_closure_emp ON employee_closure (<br>
&nbsp;&nbsp; employee_id<br>
    );</code></p>
</blockquote>

<p>The table needs to be re-populated whenever the hierarchy changes, and it is
the application's responsibility to do so -- Mondrian does not do this!
Here is an example of a stored procedure that computes a closure table.</p>

<blockquote><p>
<code>CREATE PROCEDURE close_employee()<br>
BEGIN<br>
&nbsp; DECLARE distance int;<br>
&nbsp; TRUNCATE TABLE employee_closure;<br>
&nbsp; SET distance = 0;<br>
&nbsp;
  <i>-- seed closure with self-pairs (distance 0)</i><br>
&nbsp; INSERT INTO employee_closure (supervisor_id, employee_id, distance)<br>
&nbsp;&nbsp;&nbsp; SELECT employee_id, employee_id, distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM employee;<br>
<br>
&nbsp;

  <i>-- for each pair (root, leaf) in the closure,<br>
&nbsp; -- add (root, leaf->child) from the base table</i><br>
&nbsp; REPEAT<br>
&nbsp;&nbsp;&nbsp; SET distance = distance + 1;<br>
&nbsp;&nbsp;&nbsp; INSERT INTO employee_closure (supervisor_id, employee_id, distance)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT employee_closure.supervisor_id, employee.employee_id, distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM employee_closure, employee<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE employee_closure.employee_id = employee.supervisor_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND employee_closure.distance = distance - 1;<br>
&nbsp; UNTIL (ROW_COUNT() == 0))<br>
&nbsp; END REPEAT<br>
END</code><code><br>
</p></code></blockquote>


<h3><a name="Member_properties">Member properties</a></h3>

<p>Member properties are defined by the <code><a href="#XML_Property">&lt;Property&gt;</a></code> element. You use them via the <code><i>member</i>.Properties(&quot;<i>propertyName</i>&quot;)</code>
function, for example:</p><blockquote>
  <code>SELECT {[Store Sales]} ON COLUMNS,<br>
&nbsp; TopCount(Filter([Store].[Store Name].Members,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    [Store].CurrentMember.Properties(&quot;Store Type&quot;) = &quot;Supermarket&quot;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Store Sales]) ON ROWS<br>
	FROM [Sales]</code></blockquote>

<p>Mondrian deduces the type of the property expression, if it can. If the
property name is a constant string, the type is based upon the type attribute
(&quot;String&quot;, &quot;Numeric&quot; or &quot;Boolean&quot;) of the property definition. If the property
name is an expression (for example <code>CurrentMember.Properties(&quot;Store &quot; +
&quot;Type&quot;)</code>), Mondrian will return an untyped value.</p>

<h2><a name="Advanced_physical_constructs">Advanced physical constructs</a></h2>

<h3><a name="Member_readers">Member readers</a></h3>

<p>A <dfn>member reader</dfn> is a means of
accessing members. Hierarchies are usually based upon a dimension table (an
'arm' of a star schema), and are therefore populated using SQL. But even if your
data doesn't reside in an RDBMS, you can make it appear as a hierarchy by
writing a Java class called a <dfn>custom member reader</dfn>.</p>

<p>Here are a couple of examples:</p><ol>
  <li><code>DateSource</code> (to be written) generates a time hierarchy.
  Conventionally, data warehouse implementors generate a table containing a row
  for every date their system is ever likely to deal with. But the problem is
  that this table needs to be loaded, and as time goes by, they will have to
  remember to add more rows. DateSource generates date members in memory, and on
  demand.</li><li><code>FileSystemSource</code> (to be written) presents the file system as
  a hierarchy of directories and files. Since a directory can have a parent
  which is itself a directory, it is a parent-child hierarchy. Like the time
  hierarchy created by DateSource, this is a virtual hierarchy: the member for a
  particular file is only created when, and if, that file's parent directory is
  expanded.</li><li><code>ExpressionMemberReader</code> (to be written) creates a hierarchy
  based upon an expression.</li></ol>

<p>A custom member reader must implement
<a href="http://mondrian.sourceforge.net/api/mondrian/rolap/MemberSource.html">interface
mondrian.rolap.MemberSource</a>. If you need to implement a larger set of member
operations for fine-grained control, implement the derived
<a href="http://mondrian.sourceforge.net/api/mondrian/rolap/MemberReader.html">
interface mondrian.rolap.MemberReader</a>; otherwise, Mondrian wrap your reader
in a
<a href="http://mondrian.sourceforge.net/api/mondrian/rolap/MemberSource.html">mondrian.rolap.CacheMemberReader</a>.
Your member reader must have a
public constructor which takes <code>(<a href="http://mondrian.sourceforge.net/api/mondrian/rolap/RolapHierarchy.html">Hierarchy</a>,<a href="http://java.sun.com/j2se/1.4/docs/api/java/util/Properties.html">Properties</a>)</code>
parameters, and throws no checked exceptions.</p>

<p>Member readers are declared using the <code><a href="#XML_Hierarchy">&lt;Hierarchy&gt;</a></code> element's
<code>memberReaderClass</code> attribute; any <code><a href="#XML_Parameter">&lt;Parameter&gt;</a></code> child
elements are passed via the <code>properties</code> constructor parameter. Here is an example:</p><blockquote>
  <p><code>&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Has bought dairy&quot;&gt;<br>
	&nbsp; &lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; memberReaderClass=&quot;mondrian.rolap.HasBoughtDairySource&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Level">Level</a> name=&quot;Has bought dairy&quot; uniqueMembers=&quot;true&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_Parameter">Parameter</a> name=&quot;expression&quot; value=&quot;not used&quot;/&gt;<br>
	&nbsp; &lt;/<a href="#XML_Hierarchy">Hierarchy</a>&gt;<br>
	&lt;/<a href="#XML_Dimension">Dimension</a>&gt;</code><br>
</p></blockquote>

<h3><a name="Cell_readers">Cell readers</a></h3>

<p>Not implemented yet. Syntax would be something like</p><blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;name&quot; cellReaderClass=&quot;com.foo.MyCellReader&quot;&gt;</pre></blockquote>

<p>and the class &quot;com.foo.MyCellReader&quot; would have to implement <code>
<a href="http://mondrian.sourceforge.net/api/mondrian/olap/CellReader.html">
interface mondrian.olap.CellReader</a></code>.</p>

<h3><a name="Cell_formatter">Cell formatter</a></h3>

<p>A cell formatter attribute demotes a java class to format the cell value
being displayed by
<code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/Cell.html#getFormattedValue()">getFormattedValue()</a></code>.</p><blockquote>
  <pre>&lt;<a href="#XML_Measure">Measure</a> name=&quot;name&quot; formatter=&quot;com.foo.MyCellFormatter&quot;/&gt;</pre></blockquote>

<p>The class &quot;com.foo.MyCellFormatter&quot; would have to implement <code>
<a href="http://mondrian.sourceforge.net/api/mondrian/olap/CellFormatter.html">
interface mondrian.olap.CellFormatter</a></code>.</p>

<h3><a name="Member_formatter">Member formatter</a></h3>

<p>A member formatter attribute demotes a java class to format a member's display value
returned by <code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/Member.html#getCaption()">getCaption()</a></code>.</p><blockquote>
  <pre>&lt;<a href="#XML_Level">Level</a> column=&quot;column&quot; name=&quot;name&quot; formatter=&quot;com.foo.MyMemberFormatter&quot;/&gt;</pre></blockquote>

<p>The class &quot;com.foo.MyMemberFormatter&quot; would have to implement <code>
<a href="http://mondrian.sourceforge.net/api/mondrian/olap/MemberFormatter.html">
interface mondrian.olap.MemberFormatter</a></code>.</p>

<h3><a name="I18n">Internationalization</a></h3>

<p>Internationalized applications based on Mondrian could use multiple, language-dependent schemas.
If so, the MDX statements would be language dependent too. This might be more difficult to maintain.
Instead of holding several copies of schema and MDX we provide a way to dynamically handle Mondrian schemas.
Calling <code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/DriverManager.html#getConnection(mondrian.olap.Util.PropertyList, boolean)">DriverManager.getConnection()</a></code>
we can provide a property "DynamicSchemaProcessor" denoting the name of a class to implement the
<code><a href="http://mondrian.sourceforge.net/api/mondrian/olap/DynamicSchemaProcessor.html">DynamicSchemaProcessor</a></code> interface.
So any transformation can be applied to a Mondrian schema at runtime. A "dynamic" schema will not be cached by Mondrian.
</p>

<p>To keep the MDX expressions free from language dependent names, it is a good idea to use the "caption" attribute,
which is supported for any Olap element.
Additionally:
<ul><li>A hierarchy can have an <code>allMemberCaption</code> attribute as display value of the "All" member.
</li><li>For the schema we can set a display value of the "measures" dimension by the <code>measuresCaption</code> attribute.
</li></ul>
</p>

<h4>Examples</h4>

<p>
Supposing that your DynamicSchemaProcessor supports JSTL-like resolving of variables,
you might use <code>caption</code>, <code>allMemberCaption</code> and <code>measuresCaption</code> 
attributes as follows:<blockquote>
  <p><code>&lt;<a href="#XML_Schema">Schema</a> measuresCaption=&quot;${MEASURESCAPTION}&quot;&gt;<br>
	&lt;<a href="#XML_Dimension">Dimension</a> name=&quot;Gender&quot; foreignKey=&quot;customer_id&quot; caption=&quot;${GENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; allMemberName=&quot;All Genders&quot; primaryKey=&quot;customer_id&quot; allMemberCaption=&quot;${ALLGENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Level">Level</a> name=&quot;Gender&quot; column=&quot;gender&quot; uniqueMembers=&quot;true&quot; caption=&quot;${GENDER}&quot;&gt;<br>
	&lt;<a href="#XML_Measure">Measure</a> name=&quot;Unit Sales&quot; column=&quot;unit_sales&quot; caption=&quot;${UNITSALES}&quot;&gt;</code></p></blockquote>

<p>A hierarchy with no <code>caption</code> defined would inherit the <code>caption</code> attribute from the dimension parent.</p>

<h2><a name="Advanced_aggregate_tables">Advanced aggregate tables</a></h2>
<p>
The best way to increase the performance of rolap queries is to build a
set of aggregate (summary) tables that coexist with the base fact table.
These aggregate tables contain pre-aggregated measures build from the 
fact table.
</p>
<p>
There is extensive information, both empirical and theoretical, available
on the web concerning the 
selection of which aggregate tables to create
and we will not attempt to duplicate any of it here.
</p>
<h3><a name="What_are_aggregates">What are aggregate tables</a></h3>
<p>
A fact table can have zero or more aggregate tables.
Every aggregate table is associated with just one fact table.
It aggregates the fact table measures over one or more of the dimensions.
As an example, if a particular column in the fact table represents the
number of sales of some product on a given day by a given store, then
an aggregate table might be created that sums the information so that
applies at a month level rather than by day. Such an aggregate might
reasonably be 1/30 the size of the fact table (assuming comparable sales
for every day of a month). Now, if one were to execute a MDX query
that needed sales information at a month (or quarter or year) level,
running the query against the aggregate table is faster but yields the
same answer as if it were run against the base fact table.
</p>
<p>
Further, one might create an aggregate that not only aggregates at the month
level but also, rather than at the individual store level, aggregates at
the state level. If there were, say, 20 stores per state, then this
aggregate table would b 1/600 the size of the original fact table.
MDX queries interested only at the month or above and state or above levels
would use this table.
</p>
<p>
When a MDX query runs, what aggregate should be used?
This comes down to what measures are needed and with which dimension levels?
The base fact table always has the correct measures and dimension
levels. But, it might also be true that there is one or more aggregate
tables that also have the measures and levels. Of these, the aggregate
table with the lowest cost to read, the smallest number of rows,
should be the table used to fulfill the query.
</p>
<p>
Mondrian supports two aggregation techniques which are called "lost"
dimension and "collapsed" dimension. For the creation of any
given aggregate table these can 
be applied independently to any number of different dimensions.
</p>
<p>
A "lost" dimension is one which is completely missing from the aggregate
table. The measures that appear in the table have been aggregated 
across all values of the lost dimension. As an example, in a fact table
with dimensions of time, location, and product and measure sales, for an
aggregate table that did not have the location dimension that
dimension would be "lost". Here, the sales measure would be the aggregation
over all locations. An aggregate table where all of the dimensions
are lost is possible - it would have a single row with the measure 
aggregated over everything - sales for all time, all locations and all
products.
</p>
<code>
<blockquote>
<pre>
fact table
    time_id
    product_id
    location_id
    measure

lost (time_id) dimension table
    product_id
    location_id
    measure (aggregated over time)
    fact_count

fully lost dimension table
    measure (aggregated over everything)
    fact_count
</pre>
</blockquote>
</code>
<p>
Note the "fact_count" column in the aggregate table. This additional
column is a general feature of aggregate tables. It is a count of
how many fact table columns were aggregated into the one aggregate
table row. As an example, if for a particular choice of product_id and
location_id, the time_id occurred 5 times in the fact table, then in the
aggregate table the fact_count column would contain 5 for that
product_id/location_id pair (a given product was sold at a given
location at 5 different times).
</p>
<p>
The second supported aggregation technique provides a finer level of 
control, the "collapsed" dimension technique.
Recall that the dimension key in the fact table refers (more or less) 
to the 
lowest level in the dimension hierarchy.
For a collapsed dimension, the dimension key in the aggregate
table is replaced with a set of dimension levels; the dimension key
column is replaced with a set of columns; a fully denormalized
summary table for that dimension.
As an example, if the time dimension with base fact table foreign key 
time_id had the levels: day, month, quarter and
year, and in an aggregate it was collapsed to the month level, then
the aggregate table would not have a time_id column but rather
columns for month, quarter and year. The sql generated for a
MDX query for which this aggregate table can be used, would no longer
refer to the time dimension's table but rather all time related
information would be gotten from the aggregate table.
</p>
<code>
<blockquote>
<pre>
time dimension table
    time_id
    day
    month
    quarter
    year

fact table
    time_id
    measure

collapsed dimension table
    month
    quarter
    year
    measure (aggregated to month level)
    fact_count
</pre>
</blockquote>
</code>
<p>
In the literature, there are other ways of creating aggregate tables
but they are not supported by Mondrian at this time.
</p>
<h3><a name="Building_aggregates">Building aggregate tables</a></h3>
<p>
Aggregate tables must be built.
Generally, they not real-time; they are rebuild,
for example, every night for use the following day by the analysts.
Considering the lost and collapsed dimension technique for
aggregate table definition, one can estimate that for a dimension
with N levels, there are N+1 possible aggregate tables (N collapsed and
1 lost). Also, dimensions (with different dimension tables) can
be aggregated independently. 
For the FoodMart Sales cube there are 1400 different possible aggregate 
tables.
</p>
<p>
Clearly, one does not want to create all possible aggregate tables.
Which ones to create depends upon two considerations. The first
consideration is application dependent: 
the nature of the MDX queries that will be executed.
If many of the queries deal with per month and per state questions,
then an aggregate at those levels might be created.
The second consideration is application independent: per
dimension aggregating from
the lowest level to the next lowest generally gives greater
bang for the buck than aggregating from the N to the N+1 (N&gt;1) level.
This is because 1) a first level aggregation can be used for all
queries at that level and above and 2) dimension fanout tends to 
increase for the lower levels.
Of course, your mileage may vary.
</p>
<p>
In a sense, picking which aggregate tables to build is analogous to 
picking which indexes to build on a table; it is application
dependent and experience helps.
</p>
<p>
The hardest part about the actually creation and population of 
aggregate tables is figuring out how to create the first couple;
what the SQL looks like.
After that they are pretty much all the same.
</p>
<p>
Four examples will be given. They all concern building
aggregate tables for the sales_fact_1997 fact table.
As a reminder, the sales_fact_1997 fact table looks like:
</p>
<code>
<blockquote>
<pre>
sales_fact_1997
    product_id 
    time_id 
    customer_id 
    promotion_id
    store_id
    store_sales
    store_cost
    unit_sales
</pre>
</blockquote>
</code>
<p>
The first example is a lost time dimension aggregate table, the
time_id foreign key is missing.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_l_05_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    promotion_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL
);
CREATE INDEX i_sls_97_cust_id ON agg_l_05_sales_fact_1997 ( customer_id );
CREATE INDEX i_sls_97_prod_id ON agg_l_05_sales_fact_1997 ( product_id );
CREATE INDEX i_sls_97_promo_id ON agg_l_05_sales_fact_1997 ( promotion_id );
CREATE INDEX i_sls_97_store_id ON agg_l_05_sales_fact_1997 ( store_id );

INSERT INTO agg_l_05_sales_fact_1997 (
    product_id,
    customer_id,
    promotion_id,
    store_id,
    store_sales,
    store_cost,
    unit_sales,
    fact_count
) SELECT
    product_id,
    customer_id,
    promotion_id,
    store_id,
    SUM(store_sales) AS store_sales,
    SUM(store_cost) AS store_cost,
    SUM(unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM 
    sales_fact_1997 
GROUP BY 
    product_id, 
    customer_id, 
    promotion_id, 
    store_id;
</pre>
</blockquote>
</code>
<p>
A couple of things to note here. 
</p>
<p>
The above is mysql sql, and may
not work for your database - but I hope the general idea is clear.
The aggregate table "looks like" the base fact table except the
time_id column is missing and there is a new fact_count column.
The insert statement populates the aggregate table from the base fact
table summing the measure columns and counting to populate the
fact_count column. This done while grouping by the remaining
foreign keys to the remaining dimension tables.
</p>
<p>
Next, some databases recognize star joins - Oracle for instance.
For such database one should not create indexes, not on the fact table
and not on the aggregate tables. On the other hand, databases that
do not recognize star joins will require indexes on both the
fact table and the aggregate tables.
</p>
<p>
For our purposes here, the exact name of the aggregate table is not 
important; the "agg_l_05_" preceding the base fact table's name
sales_fact_1997. First, the aggregate table name must be different
from the base fact table name. Next, the aggregate table name ought to be 
related to the base fact table name both for human eyeballing of what
aggregate is associated with which fact table, but also, as described
below, Mondrian employs mechanism to automagically recognize which
tables are aggregates of others.
</p>
<p>
The following example is a collapsed dimension aggregate table 
where the time dimension has been rolled up to the month level.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_c_14_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    promotion_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    month_of_year SMALLINT(6) NOT NULL,
    quarter VARCHAR(30) NOT NULL,
    the_year SMALLINT(6) NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL
);
CREATE INDEX i_sls_97_cust_id ON agg_c_14_sales_fact_1997 ( customer_id );
CREATE INDEX i_sls_97_prod_id ON agg_c_14_sales_fact_1997 ( product_id );
CREATE INDEX i_sls_97_promo_id ON agg_c_14_sales_fact_1997 ( promotion_id );
CREATE INDEX i_sls_97_store_id ON agg_c_14_sales_fact_1997 ( store_id );

INSERT INTO agg_c_14_sales_fact_1997 (
    product_id,
    customer_id,
    promotion_id,
    store_id,
    month_of_year,
    quarter,
    the_year,
    store_sales,
    store_cost,
    unit_sales,
    fact_count
) SELECT
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS store_sales,
    SUM(BASE.store_cost) AS store_cost,
    SUM(BASE.unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM 
    sales_fact_1997 BASE, time_by_day DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
In this case, one can see that the time_id foreign key in the base
fact table has been replaced with the columns: month_of_year, quarter,
and the_year in the aggregate table. There is, as always, the fact_count
column. The measures are inserted as sums. And, the group by clause
is over the remaining foreign keys as well as the imported time
dimension levels.
</p>
<p>
When creating a collapsed dimension aggregate one might consider creating
indexes for the columns imported from the dimension that was collapsed.
</p>
<p>
Below is another aggregate table. This one has two lost dimensions:
store_id and promotion_id, as well as collapsed dimension on time
to the quarter level. This shows how aggregate techniques can be
mixed.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_lc_100_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    quarter VARCHAR(30) NOT NULL,
    the_year SMALLINT(6) NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL
);
CREATE INDEX i_sls_97_cust_id ON agg_lc_100_sales_fact_1997 ( customer_id );
CREATE INDEX i_sls_97_prod_id ON agg_lc_100_sales_fact_1997 ( product_id );

INSERT INTO agg_lc_100_sales_fact_1997 (
    product_id,
    customer_id,
    quarter,
    the_year,
    store_sales,
    store_cost,
    unit_sales,
    fact_count
) SELECT
    BASE.product_id,
    BASE.customer_id,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS store_sales,
    SUM(BASE.store_cost) AS store_cost,
    SUM(BASE.unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM sales_fact_1997 BASE, time_by_day DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
In the above three examples, for the most part the column names
in the aggregate are the same column names that appear in the fact 
table and dimension tables. These tables would all be
recognized by the Mondrian 
<a href="#Recognizing_default">default</a>
aggregate recognizer.
It is possible to create an aggregate table and name the columns arbitrarily.
For such an aggregate, an
<a href="#Recognizing_explicit">explicit</a>
Mondrian recognizer must be specified.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_c_special_sales_fact_1997 (
    PRODUCT_ID INTEGER NOT NULL,
    CUSTOMER_ID INTEGER NOT NULL,
    PROMOTION_ID INTEGER NOT NULL,
    STORE_ID INTEGER NOT NULL,
    TIME_MONTH SMALLINT(6) NOT NULL,
    TIME_QUARTER VARCHAR(30) NOT NULL,
    TIME_YEAR SMALLINT(6) NOT NULL,
    STORE_SALES_SUM DECIMAL(10,4) NOT NULL,
    STORE_COST_SUM DECIMAL(10,4) NOT NULL,
    UNIT_SALES_SUM DECIMAL(10,4) NOT NULL,
    FACT_COUNT INTEGER NOT NULL
);
CREATE INDEX i_sls_97_cust_id ON agg_c_special_sales_fact_1997 ( CUSTOMER_ID );
CREATE INDEX i_sls_97_prod_id ON agg_c_special_sales_fact_1997 ( PRODUCT_ID );
CREATE INDEX i_sls_97_promo_id ON agg_c_special_sales_fact_1997 ( PROMOTION_ID
);
CREATE INDEX i_sls_97_store_id ON agg_c_special_sales_fact_1997 ( STORE_ID );
INSERT INTO agg_c_special_sales_fact_1997 (
    PRODUCT_ID,
    CUSTOMER_ID,
    PROMOTION_ID,
    STORE_ID,
    TIME_MONTH,
    TIME_QUARTER,
    TIME_YEAR,
    STORE_SALES_SUM,
    STORE_COST_SUM,
    UNIT_SALES_SUM,
    FACT_COUNT
) SELECT
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS STORE_SALES_SUM,
    SUM(BASE.store_cost) AS STORE_COST_SUM,
    SUM(BASE.unit_sales) AS UNIT_SALES_SUM,
    COUNT(*) AS FACT_COUNT
FROM 
    sales_fact_1997 BASE, time_by_day DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
This aggregate table has column names that are not identical to those
found in the base fact table and dimension table. It is still a 
valid aggregate but Mondrian has to be told how to map its columns
into those of the base fact table.
</p>
<p>
Sometimes with multiple aggregate tables, one aggregate table is
an aggregate of not only the base fact table but also another
aggregate table; an aggregate table with lost time and product
dimensions (no time_id and product_id foreign keys)
is an aggregate of the base fact table and an aggregate which only
has a lost time dimension (no time_id foreign key).
In this case, one might first build the aggregate with only the
lost time dimension and then build the aggregate with both lost
time and product dimensions from that first aggregate - it will be
faster (in some cases, much faster) 
to populate the second aggregate from the first rather than
from the base fact table.
</p>
<p>
One last note, when creating aggregate tables from the base fact table
pay attention to the size of the numeric columns - what might be big
enough in the base fact table might not be big enough in an aggregate.
</p>
<h3><a name="Recognizing_aggregates">Recognizing aggregate tables</a></h3>
<p>
Mondrian has to know about the aggregate tables in order to use them.
There are two ways this is done: with the default recognizer and with
a per-cube explicit definitions. 
</p>
<p>
How Mondrian recognizes aggregate table
names and columns pretty much dictates how one must name those
table names and columns when creating them in the first place!
</p>
<blockquote>
<h4><a name="Recognizing_default">Default</a></h4>
<p>
The default recognizer is baked into Mondrian and should cover most needs.
The rules are templates, designed to work for all fact table names 
and their column
names. 
These rules are templates of regular expressions 
that are instantiated with the names of a fact table
and its columns. In order to describe the rule templates, a name that
instantiate a rule are represented in a rule by have the name bracketed
by "${" and "}". As an example, 
"abc_${name}_xyz" 
is a rule parameterized
by "name". When name is "john" the template becomes 
"abc_john_xyz".
</p>
<p>
The regular expression engine used here and a definition of
the allowed regular expression grammar is found in
the Java regular expression Pattern class:
<a href=" http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern.</a>
</p>
<p>
In order that a table be recognized as an aggregate table, Mondrian
must be able to map from the fact table foreign key columns and measure
columns and those in the aggregate table. In addition, Mondrian
must identify the
fact count column in the aggregate and possible level columns (which
would appear in an aggregate table if it had a "collapsed" dimension).
What follows is a description of the steps taken in the identification
of aggregate tables by the default recognizer.
If at any step, a match fails, the table is rejected as an aggregate
table.
</p>
<p>
Starting off, the candidate aggregate table's name must comply with
the aggregate table name rule. Represented as a template regular
expression the rule is:
</p>
<blockquote>
    agg_.+_${fact_table_name}
</blockquote>
<p>
which is parameterized with the fact table's name.
(In addition, this rule is applied in "ignore case" mode.)
This means that an aggregate table's name must start with
"agg_" (ignoring character case), followed by at least one
character, then the '_' character and, lastly, the name of
the fact table. The ".+" in the template has special meaning
in a regular expression - it matches one or more characters.
</p>
<p>
As an example of applying the aggregate table name rule,
let the fact table be called 
<code>
sales_fact_1997
</code>, the 
<code>
Sales
</code>
cube's fact table from the FoodMart schema. Applying the
specific fact table name to the regular expression template
creates the following regular expression:
</p>
<blockquote>
    agg_.+_sales_fact_1997
</blockquote>
<p>
This will match the following table names:
</p>
<blockquote>
    agg_l_05_sales_fact_1997<br>
    agg_c_14_sales_fact_1997<br>
    agg_lc_100_sales_fact_1997<br>
    agg_c_special_sales_fact_1997<br>
    AGG_45_SALES_FACT_1997<br>
    AGG_drop_time_id_sales_fact_1997<br>
</blockquote>
<p>
The aggregate table name recognition mechanism has one additional
programatic feature, one can specify that only a portion of the
base fact table name be used as the basis of template name.
For instance, if the DBA demanded that all fact tables begin with the
string "fact_", e.g., 
"fact_sales_fact_1997",
one would certainly not want that string to have to
be part of each aggregate table's name. The aggregate table name
recognition mechanism allows one to specify a regular expression with
one and only one group clause (a group clause is a pattern bracketed 
by '(' and ')'). Whatever is matched by the contents of the
group clause is taken to be the part of the fact table name to be
used in the matching template. This regular expression containing the
group clause is specified as the "basename" attribute.
The default Mondrian aggregate table recognizer does not use this feature.
For more information see the associated 
<a href="developer_notes.html">developer's note link.</a>
</p>
<p>
After the default recognizer determines that a table's name matches
the aggregate table template regular expression for a given
fact table, it then attempts to match columns. The first column
tested for is the "fact count" column. Here the candidate
aggregate table must have a column called "fact_count" (ignoring
case) and this column's type must be numeric.
The following examples would match as "fact count" columns.
</p>
<blockquote>
    fact_count<br>
    FACT_COUNT<br>
    fact_COUNT<br>
</blockquote>
<p>
Following matching the "fact count" column, the candidate aggregate
table's columns are examined for possible foreign key matches.
For each of the foreign key column names in the fact table it
is determined if there are any character case independent matches
of the aggregate table's columns. Those columns that match are
noted. It is alright if no columns match; the aggregate might
be a "collapsed" dimension aggregate with no fact table foreign
keys remaining.
If the fact table had foreign key columns "store_id" and "time_id",
then the following aggregate table columns (for example) would match:
</p>
<blockquote>
    time_id<br>
    store_id<br>
    TIME_ID<BR>
    STORE_ID<Br>
    time_ID<BR>
    STORE_id<Br>
</blockquote>
<p>
At this point, matches are looked for the level and measure columns.
Both of these matching rules are multi-part - has sub rules; 
each rule has more than
one possible regular expression that might match where a match on any
one is a match.
</p>
<p>
There are three sub rules for matching level columns. Each is a template
which is parameterized with 1) the fact table's cube's dimension
hierarchy's name, "hierarchy_name", 2) the fact table's cube's dimension
hierarchy's level name, "level_name", and 3) the dimension table's level 
column name, "level_column_name":
</p>
<blockquote>
    ${hierarchy_name}_${level_name}<br>
    ${hierarchy_name}_${level_column_name}<br>
    ${level_column_name}<br>
</blockquote>
<p>
If any of these parameters have space characters, ' ', these are
mapped to underscore characters, '_', and, similarly, dot characters,
'.', are also mapped to underscores.
So, if the hierarchy_name is "Time", level_name is "Month" and 
level_column_name is month_of_year, the possible aggregate table column 
names are:
</p>
<blockquote>
    time_month<br>
    time_month_of_year<br>
    month_of_year<br>
</blockquote>
<p>
For this rule, the "hierarchy_name" and "level_name" are converted to
lower case while the "level_column_name" must match exactly.
</p>
<p>
Lastly, there is the rule for measures. There are three parameters
to matching aggregate columns to measures: 1) the fact table's
cube's measure name, "measure_name", 2) the fact table's cube's measure
column name, "measure_column_name", and 3) the fact table's cube's measure's
aggregator (sum, avg, max, etc.), "aggregate_name".
</p>
<blockquote>
    ${measure_name}<br>
    ${measure_column_name}<br>
    ${measure_column_name}_${aggregate_name}<br>
</blockquote>
<p>
where the measure name is converted to lower case and both the measure
column name and aggregate name are matched as they appear.
If the fact table's cube's measure name was, "Avg Unit Sales", 
the fact table's measure 
column name
is "unit_sales", and, lastly, the fact table's cube's measure's 
aggregate name is "avg", then possible aggregate table column names 
that would match are:
</p>
<blockquote>
    avg_unit_sales<br>
    unit_sales<br>
    unit_sales_avg<br>
</blockquote>
<!--
<blockquote>
<pre>
aggregate table name
        template rule: 
            agg_.+_${fact_table_name}
                ignore case of parameter (default)
        example:
            parameter fact_table_name == sales_fact_1997
            regular expression becomes:
                agg_.+_sales_fact_1997
            matches:
                agg_l_05_sales_fact_1997
                agg_c_14_sales_fact_1997
                agg_lc_100_sales_fact_1997
                agg_c_special_sales_fact_1997

fact_count column
        template rule: 
            fact_count (not parameterized)
                ignore case (default)
        example:
            no parameter
            regular expression becomes:
                fact_count
            matches:
                fact_count
                FACT_COUNT
                FaCt_coUNT

foreign key column
        template rule: 
            ${foreign_key}
                ignore case of parameter (default)
        example:
            parameter foreign_key == time_id
            regular expression becomes: 
                time_id
            matches:
                time_id
                TIME_ID

level column
        template rule: 
            ${hierarchy_name}_${level_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${hierarchy_name}_${level_column_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${level_column_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
        example:
            parameter hierarchy_name == Time
            parameter level_name == Month
            parameter level_column_name == month_of_year
            regular expression becomes:
                time_month
                time_month_of_year
                month_of_year
            matches:
                time_month
                time_month_of_year
                month_of_year

measure column
        template rule: 
            ${measure_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${measure_column_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${measure_column_name}_${aggregate_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
        example:
            parameter measure_name == Avg Unit Sales
            parameter measure_column_name == unit_sales
            parameter aggregate_name == avg
            regular expression becomes:
                avg_unit_sales
                unit_sales
                unit_sales_avg
            matches:
                avg_unit_sales
                unit_sales
                unit_sales_avg
</pre>
</blockquote>
-->
<p>
For Mondrian developers there are 
<a href="developer_notes.html">additional notes</a>
describing the default rule recognition schema.
</p>
<h4><a name="Recognizing_explicit">Explicit</a></h4>
<p>
On a per cube basis, in a schema file a user can both include and
exclude aggregate tables. A table that would have been include as
an aggregate by the default rules can be explicitly excluded. A
table that would not be include by the default rules can be
explicitly included. A table that would have only been partially
recognized by the default rules and, therefore, resulted in a
warning or error message, can be explicitly include in rules
specified in the cube's definition.
</p>
<p>
Below is an example for the FoodMart
<code>
Sales
</code>
cube
with fact table
<code>
sales_fact_1997
</code>.
There are child elements of the 
<code>
Table
</code>
element that deal with aggregate table recognition.
</p>
<blockquote>
<pre>
&lt;Cube name="Sales"&gt;
  &lt;Table name="sales_fact_1997"&gt;
    &lt;AggExclude name="agg_c_14_sales_fact_1997" /&gt;
    &lt;AggExclude name="agg_lc_10_sales_fact_1997" /&gt;
    &lt;AggExclude name="agg_pc_10_sales_fact_1997" /&gt;
    &lt;AggName name="agg_c_special_sales_fact_1997"&gt;
        &lt;AggFactCount column="FACT_COUNT"/&gt;
        &lt;AggIgnoreColumn column="admin_one"/&gt;
        &lt;AggIgnoreColumn column="admin_two"/&gt;
        &lt;AggForeignKey factColumn="product_id" aggColumn="PRODUCT_ID" /&gt;
        &lt;AggForeignKey factColumn="customer_id" aggColumn="CUSTOMER_ID" /&gt;
        &lt;AggForeignKey factColumn="promotion_id" aggColumn="PROMOTION_ID" /&gt;
        &lt;AggForeignKey factColumn="store_id" aggColumn="STORE_ID" /&gt;
        &lt;AggMeasure name="[Measures].[Unit Sales]" column="UNIT_SALES_SUM" /&gt;
        &lt;AggMeasure name="[Measures].[Store Cost]" column="STORE_COST_SUM" /&gt;
        &lt;AggMeasure name="[Measures].[Store Sales]" column="STORE_SALES_SUM" /&gt;
        &lt;AggLevel name="[Time].[Year]" column="TIME_YEAR" /&gt;
        &lt;AggLevel name="[Time].[Quarter]" column="TIME_QUARTER" /&gt;
        &lt;AggLevel name="[Time].[Month]" column="TIME_MONTH" /&gt;
    &lt;/AggName&gt;
    &lt;AggPattern name="agg_sales_fact_1997_.*"&gt;
      ....
      &lt;AggExclude name="agg_sales_fact_1997_olddata" /&gt;
      &lt;AggExclude pattern="agg_sales_fact_1997_test.*" /&gt;
    &lt;/AggPattern&gt;
  
  &lt;/Table&gt;
....
&lt;/Cube&gt;
</pre>
</blockquote>
<p>
The
<code>
AggExclude
</code>
elements define tables that should not be considered aggregates of the
fact table. In this case Mondrian is instructed to ignore the tables
<code>
agg_c_14_sales_fact_1997,
</code>
<code>
agg_lc_10_sales_fact_1997
</code>
and
<code>
agg_pc_10_sales_fact_1997.
</code>
Following the excludes is the 
<code>
AggName
</code>
element which identifies the name of an aggregate table
table,
<code>
agg_c_special_sales_fact_1997,
</code>
and rules for mapping names from the fact table and cube to it.
The two
<code>
AggIgnoreColumn
</code>
elements are used to specifically state to Mondrian that the columns
<code>
admin_one
</code>
and
<code>
admin_two
</code>
are known and should be ignored. If these columns were not so
identified, Mondrian at the end of determining the fitness of 
the 
<code>
agg_c_special_sales_fact_1997
</code>
table to be an aggregate  of the 
<code>
sales_fact_1997
</code>
fact table would complain that there were extra unidentified columns
and that the mapping was incomplete.
The
<code>
AggForeignKey
</code>
elements define mappings from the 
<code>
sales_fact_1997
</code>
fact table foreign key column 
names into the
<code>
agg_c_special_sales_fact_1997
</code>
aggregate table column names.
</p>
<p>
Both the
<code>
AggMeasure
</code>
and
<code>
AggLevel
</code>
elements map "logical" name, names defined in the cube's schema,
to the aggregate table's column names.
An aggregate table does not have to have all of the measures
that are found in the base fact table, so it is not a requirement
that all of the fact table measures appear as 
<code>
AggMeasure
</code>
mappings, though it will certainly be the most common case.
The most notable exception are 
<code>
distinct count
</code>
measures; such a measure can be aggregated, but one can not
aggregate further on the measure - the "distinctness" of the
measure has been lost during the first aggregation.
</p>
<p>
The
<code>
AggLevel
</code>
entries correspond to collapsed dimensions. For each collapsed
dimension there is a hierarchy of levels spanning from the top
level down to some intermediate level (with no gaps).
</p>
<p>
The 
<code>
AggName
</code>
element is followed by an
<code>
AggPattern
</code>
element.
This matches candidate aggregate table names using a 
regular expression. Included as child elements of the
<code>
AggPattern
</code>
element are two
<code>
AggExclude
</code>
elements. These specifically state what table names should not
be considered by this
<code>
AggPattern
</code>
element.
</p>
<p>
In a given
<code> 
Table
</code>
element all of the 
<code>
AggExclude
</code>
are applied first, followed by the
<code>
AggName
</code>
element rules and then the
<code>
AggPattern
</code>
rules.
In the case where the same fact table is used by multiple cubes,
the above still applies, but its across all of the aggregation
rules in all of the multiple cube's
<code> 
Table
</code>
elements.
The first "Agg" element,
name or pattern, that matches per candidate aggregate table
name has its associated rules applied.
</p>

<p>
Most of the time, the scope of these
include/exclude statements apply only to the cube in question, but
not always. A cube has a fact table and it is the characteristics
of the fact table (like column names) against
which some of the aggregate table rules are applied. But, a fact table
can actually be the basis of more than one cube. In the FoodMart
schema the 
<code>
sales_fact_1997
</code>
fact table applies to both the 
<code>
Sales
</code>
and the
<code>
Sales Ragged
</code>
cubes.
What this means is that any explicit rules defined in the 
<code>
Sales
</code>
cube also applies to the 
<code>
Sales Ragged
</code>
cube and visa versa.
</p>
<p>
One feature of the explicit recognizer is very useful. With a single
line in the cubes definition in the schema file, 
one can force Mondrian not to recognize any aggregate tables
for the cube's fact table. As an example, for the FoodMart Sales cube
the following excludes all aggregate tables because the regular expression 
pattern
<code>
".*"
</code>
matches all candidate aggregate table names.
</p>
<blockquote>
<pre>
&lt;Table name="sales_fact_1997" &gt;
&nbsp; &nbsp; &lt;AggExclude pattern=".*" /&gt;
&lt;/Table&gt;
</pre>
</blockquote>
<p>
During aggregate table recognition, 
rather than fail silently, Mondrian is rather noisy about things
it can not figure out.
</p>
<h3><a name="Aggregate_properties">Aggregate properties</a></h3>
<p>
Mondrian has properties that control the behavior of its aggregate
table sub-system.
</p>
<p>
</p>
<table style="text-align: left; "
 border="1" cellpadding="2" cellspacing="0">
  <tbody>
    <tr>
      <td style="vertical-align: top; text-align: center;">
        <span style="font-weight: bold;">Property</span><br>
      </td>
      <td style="vertical-align: top; text-align: center;">
        <span style="font-weight: bold;">Type</span><br>
      </td>
      <td style="vertical-align: top; text-align: center;">
        <span style="font-weight: bold;">Default Value</span><br>
      </td>
      <td style="vertical-align: top; text-align: center;">
        <span style="font-weight: bold;">Description</span><br>
      </td>
    </tr>
    <tr>

    <tr>
      <td style="vertical-align: top;"><code>mondrian.rolap.aggregates.Use</code></td>
      <td style="vertical-align: top;"><code>boolean</code></td>
      <td style="vertical-align: top;"><code>false</code></td>
      <td style="vertical-align: top;">
        If set to true, then Mondrian reads the database schema and
        recognizes aggregate tables. These tables are then candidates
        for use in fulfilling MDX queries.
        If set to false, then no aggregate table related activity 
        takes place in Mondrian.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><code>mondrian.rolap.aggregates.ChooseByVolume</code></td>
      <td style="vertical-align: top;"><code>boolean</code></td>
      <td style="vertical-align: top;"><code>false</code></td>
      <td style="vertical-align: top;">
        Currently, Mondrian support to algorithms for selecting which
        aggregate table to use: the aggregate with smallest row count
        or the aggregate with smallest volume (row count * row size).
        If set to false, then row count is used. If true, then volume
        is used.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><code>mondrian.rolap.aggregates.rules</code></td>
      <td style="vertical-align: top;"><code>resource or url</code></td>
      <td style="vertical-align: top;"><code>/DefaultRules.xml</code></td>
      <td style="vertical-align: top;">
        This is a developer property, not a user property.
        Setting this to a url (e.g., file://c:/myrules.xml) allows one
        to use their own "default" Mondrian aggregate table recognition
        rules. 
        In general use this should never be changed from the default value.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><code>mondrian.rolap.aggregates.rule.tag</code></td>
      <td style="vertical-align: top;"><code>string</code></td>
      <td style="vertical-align: top;"><code>default</code></td>
      <td style="vertical-align: top;">
        This is also a developer property. It allows one to pick which 
        named rule in the default rule file to use.
        In general use this should never be changed from the default value.
      </td>
    </tr>
  </tbody>
</table>



<h2><a name="Access_control">Access-control</a></h2>

<p>OK, so now you've got all this great data, but you don't everyone to be able to read all
of it. To solve this, you can define an access-control profile, called a Role, as part of the
schema, and set this role when establishing a connection.</p>

<h3><a name="Defining_roles">Defining a role</a></h3>

<p>Roles are defined by <code><a href="#XML_Role">&lt;Role&gt;</a></code> elements,
which occur as direct children of the <code><a href="#XML_Schema">&lt;Schema&gt;</a></code>
element, after the last <code><a href="#XML_Cube">&lt;Cube&gt;</a></code>. Here is an example of a role:</p><blockquote>
  <p><code>&lt;<a href="#XML_Role">Role</a> name=&quot;California manager&quot;&gt;<br>
	&nbsp; &lt;<a href="#XML_SchemaGrant">SchemaGrant</a> access=&quot;none&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_CubeGrant">CubeGrant</a> cube=&quot;Sales&quot; access=&quot;all&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Store]&quot; access=&quot;custom&quot; topLevel=&quot;[Store].[Store Country]&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Store].[USA].[CA]&quot; access=&quot;all&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Store].[USA].[CA].[Los Angeles]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_HierarchyGrant">HierarchyGrant</a>&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Customers]&quot; access=&quot;custom&quot; topLevel=&quot;[Customers].[State Province]&quot; bottomLevel=&quot;[Customers].[City]&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Customers].[USA].[CA]&quot; access=&quot;all&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_MemberGrant">MemberGrant</a> member=&quot;[Customers].[USA].[CA].[Los Angeles]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_HierarchyGrant">HierarchyGrant</a>&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_HierarchyGrant">HierarchyGrant</a> hierarchy=&quot;[Gender]&quot; access=&quot;none&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_CubeGrant">CubeGrant</a>&gt;<br>
	&nbsp; &lt;/<a href="#XML_SchemaGrant">SchemaGrant</a>&gt;<br>
	&lt;/<a href="#XML_Role">Role</a>&gt;</code></p></blockquote>

<p>A <code><a href="#XML_SchemaGrant">&lt;SchemaGrant&gt;</a></code> defines the default access for
objects in a schema. The <code>access</code> attribute can be &quot;all&quot; or &quot;none&quot;;
this access can be overridden for specific objects. In this case, because
<code>access=&quot;none&quot;</code>, a user would only be able to browse the &quot;Sales&quot; cube,
because it is explicitly granted.</p>

<p>A <code><a href="#XML_CubeGrant">&lt;CubeGrant&gt;</a></code> defines the access to
a particular cube. As for <code><a href="#XML_SchemaGrant">&lt;SchemaGrant&gt;</a></code>, the access attribute can be &quot;all&quot; or &quot;none&quot;, and can
be overridden for specific sub-objects in the cube.</p>

<p>A <code><a href="#XML_HierarchyGrant">&lt;HierarchyGrant&gt;</a></code> defines
access to a hierarchy. The access attribute can be &quot;all&quot;, meaning all members
are visible; &quot;none&quot;, meaning the hierarchy's very existence is hidden from the
user; and &quot;custom&quot;. With custom access, you can use the <code>topLevel</code>
attribute to define the top level which is visible (preventing users from seeing
too much of the 'big picture', such as viewing revenues rolled up to the <code>
Store Country</code> level); or use the <code>bottomLevel</code> attribute to
define the bottom level which is visible (here, preventing users from invading
looking at individual customers' details); or control which sets of members the
user can see, by defining nested <a href="#XML_MemberGrant">&lt;MemberGrant&gt;</a>
elements.</p>

<p>You can only define a <code><a href="#XML_MemberGrant">&lt;MemberGrant&gt;</a></code>
element if its enclosing <code><a href="#XML_HierarchyGrant">&lt;HierarchyGrant&gt;</a></code>
has <code>access=&quot;custom&quot;</code>. Member grants give (or remove) access to a
given member, and all of its children. Here are the rules:</p><ol>
  <li><b>Members inherit access from their parents</b>. If you deny access to
  California, you won't be able to see San Francisco.</li><li><b>Grants are order-dependent</b>. If you grant access to USA, then deny
  access to Oregon, then you won't be able to see Oregon, or Portland. But if
  you were to deny access to Oregon, then grant access to USA, you can
  effectively see everything.</li><li><b>A member is visible if any of its children are visible</b>. Suppose you
  deny access to USA, then grant access to California. You will be able to see
  USA, and California, but none of the other states. The totals against USA will
  still reflect all states, however.</li><li><b>Member grants don't override the hierarchy grant's top- and
  bottom-levels</b>. If you set <code>topLevel=&quot;[Store].[Store State]&quot;</code>,
  and grant access to California, you won't be able to see USA.</li></ol>

<p>In the example, the user will have access to California, and all of the
cities in California except Los Angeles. They will be able to see USA (because
its child, California, is visible), but no other nations, and not All Stores
(because it is above the top level, <code>Store Country</code>).</p>

<h3><a name="Setting_a_connections_role">Setting a connection's role</a></h3>

<p>A role only has effect when it is associated with a connection. By default,
connections have a role which gives them access to every
cube in that connection's schema. </p>

<p>Most databases associate roles (or 'groups') with users, and automatically
assign them when users log in. However, Mondrian doesn't have the notion of
users, so you have to establish the role in a different way. There are two ways
of doing this:</p><ol>
  <li><b>In the connect string</b>. If you specify the <code>Role</code> keyword
  in the connect string, the connection will adopt that role. See
  <a href="http://mondrian.sourceforge.net/api/mondrian/olap/DriverManager.html">
  class DriverManager</a> for examples of connect string syntax.</li><li><b>Programmatically</b>. Once your application has established a
  connection, call the method
  <a href="http://mondrian.sourceforge.net/api/mondrian/olap/Connection.html#setRole(mondrian.olap.Role)">
  Connection.setRole(Role)</a>. You can create a Role programmatically (see
  <a href="http://mondrian.sourceforge.net/api/mondrian/olap/Role.html">class
  Role</a> for more details), or look
  one up using the method
  <a href="http://mondrian.sourceforge.net/api/mondrian/olap/Schema.html#lookupRole(java.lang.String)">
  Schema.lookupRole(String)</a>.</li></ol>

<h2><a name="Appendix_A_XML_elements">Appendix A: XML elements</a></h2><table border="2" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="AutoNumber2">
  <tr>
    <th>Element</th>
    <th>Description</th></tr><tr>
    <td>&nbsp;</td><td>&nbsp;</td></tr><tr>
    <td><code>&lt;<a name="XML_Schema" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Schema">Schema</a>&gt;</code></td><td>Collection of Cubes, Virtual cubes,  Shared dimensions, and Roles.</td></tr><tr>
    <td colspan="2"><i><br>
	Logical elements</i></td></tr><tr>
    <td><code>&lt;<a name="XML_Cube" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Cube">Cube</a>&gt;</code></td><td>A collection of dimensions and measures, all centered on a fact table.</td></tr><tr>
    <td><code>&lt;<a name="XML_VirtualCube" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#VirtualCube">VirtualCube</a>&gt;</code></td><td>A cube defined by combining the dimensions and measures of one or more
    cubes.</td></tr><tr>
    <td><code>&lt;<a name="XML_Dimension" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Dimension">Dimension</a>&gt;</code></td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_DimensionUsage" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#DimensionUsage">DimensionUsage</a>&gt;</code></td><td>Usage of a shared dimension by a cube.</td></tr><tr>
    <td><code>&lt;<a name="XML_Hierarchy" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Hierarchy">Hierarchy</a>&gt;</code></td><td>
	Hierarchy.</td>
  </tr>
  <tr>
    <td colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Level" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Level">Level</a>&gt;</code></td><td>
	Level of a hierarchy.</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Property" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Property">Property</a>&gt;</code></td><td>Member property. The definition is against 
	a hierarchy or level, but the
    property will be available to all members.</td></tr><tr>
    <td><code>&lt;<a name="XML_Measure" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Measure">Measure</a>&gt;</code></td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#CalculatedMember" name="XML_CalculatedMember">CalculatedMember</a>&gt;</code></td><td>A member whose value is derived using a formula, defined as part of a
    cube.</td></tr><tr>
    <td colspan="2"><i><br>
	Physical elements</i></td></tr><tr>
    <td><code>&lt;<a name="XML_Table" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Table">Table</a>&gt;</code></td><td>Fact- or dimension table.</td></tr><tr>
    <td><code>&lt;<a name="XML_View" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#View">View</a>&gt;</code></td><td>Defines a 'table' using a SQL query, which can have
    different variants for different underlying databases.</td></tr><tr>
    <td><code>&lt;<a name="XML_Join" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Join">Join</a>&gt;</code></td><td>Defines a 'table' by joining a set of queries.</td></tr><tr>
    <td><code>&lt;<a name="XML_Closure" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Closure">Closure</a>&gt;</code></td>
    <td>Maps a parent-child hierarchy onto a closure table.</td></tr><tr>
    <td colspan="2"><i><br>
	Aggregate Tables</i></td></tr><tr>
    <td><code>&lt;<a name="XML_AggExclude" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggExclude">AggExclude</a>&gt;</code></td>
    <td>Exclude a candidate aggregate table by name or pattern matching.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggName" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggName">AggName</a>&gt;</code></td>
    <td>Match a candidate aggregate table by name.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggPattern" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggPattern">AggPattern</a>&gt;</code></td>
    <td>Match a candidate aggregate table by regular expression pattern.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggFactCount" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggFactCount">AggFactCount</a>&gt;</code></td>
    <td>Specify name of fact_count column for a candidate aggregate table.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggIgnoreColumn" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggIgnoreColumn">AggIgnoreColumn</a>&gt;</code></td>
    <td>Provide name of a column that should be ignored.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggForeignKey" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggForeignKey">AggForeignKey</a>&gt;</code></td>
    <td>Specify mapping from fact table foreign key to candidate aggregate table foreign key column.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggMeasure" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggMeasure">AggMeasure</a>&gt;</code></td>
    <td>Specify mapping from measure name to candidate aggregate table column.</td></tr><tr>
    <td><code>&lt;<a name="XML_AggLevel" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#AggLevel">AggLevel</a>&gt;</code></td>
    <td>Specify mapping from level name to candidate aggregate table column.</td></tr><tr>
    <td colspan="2"><i><br>
	Access control</i></td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Role" name="XML_Role">Role</a>&gt;</code></td><td>An access-control profile.</td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#SchemaGrant" name="XML_SchemaGrant">SchemaGrant</a>&gt;</code></td><td>A set of rights to a schema.</td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#CubeGrant" name="XML_CubeGrant">CubeGrant</a>&gt;</code></td><td>A set of rights to a cube.</td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#HierarchyGrant" name="XML_HierarchyGrant">HierarchyGrant</a>&gt;</code></td><td>A set of rights to a hierarchy and levels within that hierarchy.</td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#MemberGrant" name="XML_MemberGrant">MemberGrant</a>&gt;</code></td><td>A set of rights to a member and its children.</td></tr><tr>
    <td colspan="2"><i><br>
	Miscellaneous</i></td></tr><tr>
    <td><code>&lt;<a href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Parameter" name="XML_Parameter">Parameter</a>&gt;</code></td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_Table" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#Table">Table</a>&gt;</code></td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>&lt;<a name="XML_CalculatedMemberProperty" href="http://perforce.eigenbase.org:8080/open/mondrian/src/main/mondrian/olap/Mondrian.xml#MemberProperty">CalculatedMemberProperty</a>&gt;</code></td><td>Property of a calculated member.</td></tr></table>

<hr>

<table border="0" class="clsStd" width="100%" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
  <tr>
    <td class="content">
      <a target="_top" href="index.html">Home</a> |
      <a target="_top" href="schema.html">No frames</a> | This file is<i>
      <a href="http://mondrian.sourceforge.net/schema.html">$Id$
      </a></i> (<a href="http://perforce.eigenbase.org:8080/open/mondrian/doc/schema.html?ac=22">log</a>)</td><td align="right">
      <a href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=35302&type=1" width="88" height="31" border="0" alt="SourceForge.net Logo">
      </a>
    </td>
  </tr>
</table>

</body>
</html>
