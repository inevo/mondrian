<html>
<!--
  == $Id$
  == This software is subject to the terms of the Common Public License
  == Agreement, available at the following URL:
  == http://www.opensource.org/licenses/cpl.html.
  == (C) Copyright 2001-2002 Kana Software, Inc. and others.
  == All Rights Reserved.
  == You must accept the terms of that agreement to use this software.
  == jhyde, 24 September, 2002
  -->

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>What is OLAP?</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css" />
</head>

<body>
<h1><font size="7">Mondrian</font></h1>
<hr>

<table cellSpacing="0" cellPadding="0" border="0">
<tr>
<!-- Start links -->
<td valign="top">
<p dir="ltr">
<a href="index.html">Home</a><br>
<a href="install.html">Download</a><br>
Overview<br>
&nbsp;&nbsp;&nbsp;<a href="olap.html">What&nbsp;is&nbsp;OLAP?</a><br>
&nbsp;&nbsp;&nbsp;<a href="architecture.html">Architecture</a><br>
&nbsp;&nbsp;&nbsp;<a href="faq.html">FAQ</a><br>
Design<br>
&nbsp;&nbsp;&nbsp;<a href="components.html">Components</a><br>
&nbsp;&nbsp;&nbsp;<a href="api/index.html">API</a><br>
<a href="links.html">Links</a><br>
&nbsp;&nbsp;&nbsp;<a href="people.html">People</a><br>
&nbsp;&nbsp;&nbsp;<a href="http://sourceforge.net/projects/mondrian/">Project</a><br>
&nbsp;&nbsp;&nbsp;<a href="help.html">Help</a><br>
</td>
<!-- End links -->
<td width="5"><img height="1" src="spacer.gif" width="5" border="0"></td>
<td width="1" bgcolor="#999999"><img height="1" src="spacer.gif" width="1" border="0"></td>
<td width="5"><img height="1" src="spacer.gif" width="5" border="0"></td>
<td valign="top">

<h2>What is Mondrian?</h2>

<p>Mondrian is an OLAP engine written in Java. It executes queries written in 
the MDX language, reading data from a relational database (RDBMS), and presents 
the results in a multidimensional format via a Java API. Let's go into what that 
means.</p>
<h2>Online Analytical Processing</h2>
<p><dfn><font face="Verdana">Online Analytical Processing (OLAP)</font></dfn> 
means analysing large quantities of data in real-time. Unlike Online Transaction 
Processing (OLTP), where typical operations read and modify individual and small 
numbers of records, OLAP deals with data in bulk, and operations are generally 
read-only. The term 'online' implies that even though huge quantities of data 
are involved — typically many millions of records, occupying several gigabytes 
— the system must respond to queries fast enough to allow an interactive 
exploration of the data. As we shall see, that presents considerable technical 
challenges.</p>
<p>OLAP employs a technique called <dfn><font face="Verdana">Multidimensional Analysis</font></dfn>. Whereas a 
relational database stores all data in the form of rows and columns, a 
multidimensional dataset consists of <dfn><font face="Verdana">axes</font></dfn> and 
<dfn><font face="Verdana">cells</font></dfn>. Consider the dataset</p>
<blockquote>
  <table border="2" style="clsStd; border-collapse:collapse" id="AutoNumber1" cellpadding="2" bordercolor="#111111" cellspacing="0">
    <tr>
      <td nowrap><i>Year</i></td>
      <th align="right" colspan="2">2000</th>
      <th align="right" colspan="2">2001</th>
      <th align="right" colspan="2">Growth</th>
    </tr>
    <tr>
      <td nowrap><i>Product</i></td>
      <th align="right">Dollar sales</th>
      <th align="right">Unit sales</th>
      <th align="right">Dollar sales</th>
      <th align="right">Unit sales</th>
      <th align="right">Dollar sales</th>
      <th align="right">Unit sales</th>
    </tr>
    <tr>
      <th nowrap align="left">Total</th>
      <td align="right">$17,165</td>
      <td align="right">$2,825</td>
      <td align="right">$18,867</td>
      <td align="right">3,163</td>
      <td align="right">10%</td>
      <td align="right">12%</td>
    </tr>
    <tr>
      <th nowrap align="left">— Books</th>
      <td align="right">$12,845</td>
      <td align="right">956</td>
      <td align="right">$14,562</td>
      <td align="right">1,121</td>
      <td align="right">13%</td>
      <td align="right">17%</td>
    </tr>
    <tr>
      <th nowrap align="left">—— Fiction</th>
      <td align="right">$1,341</td>
      <td align="right">424</td>
      <td align="right">$1,202</td>
      <td align="right">380</td>
      <td align="right">16%</td>
      <td align="right">37%</td>
    </tr>
    <tr>
      <th nowrap align="left">—— Non-fiction</th>
      <td align="right">$1,412</td>
      <td align="right">400</td>
      <td align="right">$1,224</td>
      <td align="right">386</td>
      <td align="right">11%</td>
      <td align="right">2%</td>
    </tr>
    <tr>
      <th nowrap align="left">— Magazines</th>
      <td align="right">$2,753</td>
      <td align="right">824</td>
      <td align="right">$2,426</td>
      <td align="right">766</td>
      <td align="right">-12%</td>
      <td align="right">-7%</td>
    </tr>
    <tr>
      <th nowrap align="left">&mdash; Greetings cards</th>
      <td align="right">$1,567</td>
      <td align="right">1,045</td>
      <td align="right">$1,879</td>
      <td align="right">1,276</td>
      <td align="right">20%</td>
      <td align="right">22%</td>
    </tr>
    </table>
</blockquote>


<p>The rows axis consists of the members 'All products', 'Books', 'Fiction', and 
so forth, 
and the columns axis consists of the cartesian product of the years '2000' and 
'2001', and the <font face="Verdana">calculation</font> 'Growth', and the 
<dfn>measures</dfn> 'Unit sales' and 'Dollar sales'. Each cell 
represents the sales of a product category in a particular year; for example, 
the dollar sales of Magazines in 2001 were $2426.</p>
<p>This is a richer view of the data than would be presented by a relational 
database. The members of a multidimensional dataset are not always values 
from a relational column. 'Total', 'Books' and 'Fiction' are members at 
successive levels in a <dfn>hierarchy</dfn>, each of 
which is rolled up to the next. And even though it is alongside the years '2000' 
and '2001', 'Growth' is 
a <dfn>calculated member</dfn>, which introduces a
formula for computing cells from other 
cells.</p>
<p>The dimensions used here — products, time, and measures — are just three of 
many dimensions by which the dataset can be categorized and filtered. The 
collection of dimensions, hierarchies and measures is called a <dfn>
<font face="Verdana">cube</font></dfn>.</p>
<p>I hope I have demonstrated that multidimensional  is above all a way of <em>
<font face="Verdana">presenting</font></em> data. Although some multidimensional 
databases <em><font face="Verdana">store</font></em> the data in multidimensional format, 
I shall argue that it is simpler to store the data in relational format. It's 
time to look at the architecture of an OLAP system.</p>
<h2>Architecture</h2>
<p>A Mondrian OLAP System consists of four layers; working from the eyes of the 
end-user to the bowels of the data center, these are the presentation layer, the 
calculation layer, the aggregation layer, and the storage layer.</p>
<p>The <dfn><font face="Verdana">presentation layer</font></dfn> determines what 
the end-user sees on his or her monitor, and how he or she can interact to ask 
new questions. There are many ways to present multidimensional datasets, 
including pivot tables (an interactive version of the table shown above), pie, 
line and bar charts, and advanced visualization tools such as clickable maps and 
dynamic graphics. These might be written in Swing or JSP, charts rendered in 
JPEG or GIF format, or transmitted to a remote application via XML. What all of 
these forms of presentation have in common is the multidimensional 'grammar' of 
dimensions, measures and cells in which the presentation layer asks the question 
is asked, and OLAP server returns the answer.</p>
<p>The second layer is the <dfn><font face="Verdana">calculation layer</font></dfn>. 
The calculation layer parses, validates and executes MDX queries. A query is 
evaluted in multiple phases. The axes are computed first, then the values of the 
cells within the axes. For efficiency, the calculation layer sends cell-requests 
to the aggregation layer in batches. A <dfn>
<font face="Verdana">query transformer</font></dfn> allows the application to 
manipulate existing queries, rather than building an MDX statement from scratch 
for each request. And <dfn>
<font face="Verdana">metadata</font></dfn> describes the the dimensional model, 
and how it maps onto the relational model.</p>
<p>The third layer is the <dfn><font face="Verdana">aggregation layer</font></dfn>. 
An aggregation is a set of measure values ('cells') in memory, qualified by a 
set of dimension column values. The calculation layer sends requests for sets of 
cells. If the requested cells are not in the cache, or derivable by rolling up 
an aggregation in the cache, the aggregation manager and sends a request to the 
storage layer.</p>
<p>The <dfn><font face="Verdana">storage layer</font></dfn> is an RDBMS. It is 
responsible for providing aggregated cell data, and members from dimension 
tables. I describe <a href="#Storage_and_aggregation_strategies">below</a> why I 
decided to use the features of the RDBMS rather than developing a storage system 
optimized for multidimensional data.</p>
<p>All four of these components can exist on the same machine. Layers 2 and 3, 
which comprise the Mondrian server, must be on the same machine. The storage 
layer could be on another machine, accessed via remote JDBC connection. In a 
multi-user system, the presentation layer would exist on each end-user's machine 
(except in the case of JSP pages generated on the server).</p>
<h3><a name="Storage_and_aggregation_strategies">Storage and aggregation 
strategies</a></h3>
<p>OLAP Servers are generally categorized according to how they store their 
data:</p>
<ul>
  <li>A <font face="Verdana"><dfn>MOLAP (multidimensional OLAP)</dfn></font> 
  server stores all of its data on disk in structures optimized for 
  multidimensional access. Typically, data is stored in dense arrays, requiring 
  only 4 or 8 bytes per cell value.</li>
  <li>A <font face="Verdana"><dfn>ROLAP (relational OLAP)</dfn></font> server 
  stores its data in a relational database. Each row in a fact table has a 
  column for each dimension and measure.</li>
</ul>
<p>Three kinds of data need to be stored: fact table data (the transactional 
records), aggregates, and dimensions.</p>
<p>MOLAP databases store fact data in multidimensional format, but if there are 
more than a few dimensions, this data will be sparse, and the multidimensional 
format does not perform well. A <font face="Verdana"><dfn>HOLAP (hybrid OLAP)</dfn></font> 
system solves this problem by leaving the most granular data in the relational 
database, but stores aggregates in multidimensional format.</p>
<p>Pre-computed aggregates are necessary for large data sets, otherwise certain 
queries could not be answered without reading the entire contents of the fact 
table. MOLAP aggregates are often an image of the in-memory data structure, 
broken up into pages and stored on disk. ROLAP aggregates are stored in tables. 
In some ROLAP systems these are explicitly managed by the OLAP server; in other 
systems, the tables are declared as materialized views, and they are implicitly 
used when the OLAP server issues a query with the right combination of columns 
in the <code>group by</code> clause.</p>
<p>The final component of the aggregation strategy is the cache. The cache holds 
pre-computed aggregations in memory so subsequent queries can access cell values 
without going to disk. If the cache holds the required data set at a lower level 
of aggregation, it can compute the required data set by rolling up.</p>
<p>The cache is arguably the most important part of the aggregation strategy 
because it is <em><font face="Verdana">adaptive</font></em>. It is difficult to 
choose a set of aggregations to pre-compute which speed up the system without 
using huge amounts of disk, particularly those with a high dimensionality or if 
the users are submitting unpredictable queries. And in a system where data is 
changing in real-time, it is impractical to maintain pre-computed aggregates. A 
reasonably sized cache can allow a system to perform adequately in the face of 
unpredictable queries, with few or no pre-computed aggregates.</p>
<p>Mondrian's aggregation strategy is as follows:</p>
<ul>
  <li>Fact data is stored in the RDBMS. Why develop a storage manager when the 
  RDBMS already has one?</li>
  <li>Read aggregate data into the cache by submitting <code>group by</code> 
  queries. Again, why develop an aggregator when the RDBMS has one?</li>
  <li><em><font face="Verdana">If</font></em> the RDBMS supports materialized 
  views, <em><font face="Verdana">and </font></em>the database administrator 
  chooses to create materialized views for particular aggregations, then 
  Mondrian will use them implicitly. Ideally, Mondrian's aggregation manager 
  should be aware that these materialized views exist and that those particular 
  aggregations are cheap to compute. If should even offer tuning suggestings to 
  the database administrator.</li>
</ul>
<p>The general idea is to delegate unto the database what is the database's. 
This places additional burden on the database, but once those features are added 
to the database, all clients of the database will benefit from them. 
Multidimensional storage would reduce I/O and result in faster operation in some 
circumstances, but I don't think it warrants the complexity at this stage.</p>
<p>A wonderful side-effect is that because Mondrian requires no storage of its 
own, it can be installed by adding a JAR file to the class path and be up and 
running immediately. Because there are no redundant data sets to manage, the 
data-loading process is easier, and Mondrian is ideally suited to do OLAP on 
data sets which change in real time.</p>
<p><i>Note to self</i>: The cache manager ought to distinguish between data which is being 
pulled into the cache to be rolled up immediately into some other aggregation, 
and an aggregation which is explicitly needed.</p>
</td>
</tr>
</table>

<hr>

<table border="0" class="clsStd" width="100%" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
  <tr>
    <td>
      <a href="http://apoptosis.dyndns.org:8080/open/mondrian/doc/components.html">$Id$
      </a>(<a href="http://apoptosis.dyndns.org:8080/open/mondrian/doc/components.html?ac=22">log</a>)</td>
    <td align="right">
      <a href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=35302&type=1" width="88" height="31" border="0" alt="SourceForge.net Logo">
      </a>
    </td>
  </tr>
</table>
  
</body>
</html>
