/* 
 * SchemaExplorer.java
 * 
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 * http://www.opensource.org/licenses/cpl.html.
 * Copyright (C) 1999-2003 Kana Software, Inc. and others.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * 
 * Created on October 2, 2002, 5:42 PM
 * Modified on 15-Jun-2003 by ebengtso
 *  
 */


package mondrian.gui;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;

import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.TableCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;

import mondrian.olap.MondrianDef;
import mondrian.olap.MondrianDef.Schema;

/**
 *
 * @author  sean
  */
public class SchemaExplorer extends javax.swing.JPanel implements TreeSelectionListener{
	MondrianDef.Schema schema;
	SchemaTreeModel model;
	SchemaTreeCellRenderer renderer;
	File schemaFile;
    
	/** Creates new form SchemaExplorer */
	public SchemaExplorer() {
		initComponents();
	}
    
	public SchemaExplorer(File f) {
		this();
		try {
			mondrian.xom.Parser xmlParser =
					mondrian.xom.XOMUtil.createDefaultParser();
			this.schemaFile = f;
            
			schema = new MondrianDef.Schema(
					xmlParser.parse(schemaFile.toURL()));

			renderer = new SchemaTreeCellRenderer();
			model = new SchemaTreeModel(schema);
			tree.setModel(model);
			tree.setCellRenderer(renderer);
			tree.addTreeSelectionListener(this);
			SchemaPropertyCellEditor spce = new SchemaPropertyCellEditor();
			propertyTable.setDefaultEditor(Object.class, spce);
			SchemaPropertyCellRenderer spcr = new SchemaPropertyCellRenderer();
			propertyTable.setDefaultRenderer(Object.class, spcr);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents() {//GEN-BEGIN:initComponents
		jSplitPane1 = new javax.swing.JSplitPane();
		jPanel1 = new javax.swing.JPanel();
		jScrollPane2 = new javax.swing.JScrollPane();
		propertyTable = new javax.swing.JTable();
		targetLabel = new javax.swing.JLabel();
		jPanel2 = new javax.swing.JPanel();
		jScrollPane1 = new javax.swing.JScrollPane();
		tree = new javax.swing.JTree();
		jToolBar1 = new javax.swing.JToolBar();
		addCubeButton = new javax.swing.JButton();
		addDimensionButton = new javax.swing.JButton();
		addMeasureButton = new javax.swing.JButton();
		addLevelButton = new javax.swing.JButton();
		addPropertyButton = new javax.swing.JButton();
		jPanel3 = new javax.swing.JPanel();
		cutButton = new javax.swing.JButton();
		copyButton = new javax.swing.JButton();
		pasteButton = new javax.swing.JButton();

		setLayout(new java.awt.BorderLayout());

		jSplitPane1.setDividerLocation(200);
		jPanel1.setLayout(new java.awt.BorderLayout());

		propertyTable.setModel(new javax.swing.table.DefaultTableModel(
			new Object [][] {

			},
			new String [] {
				"Property", "Value"
			}
		) {
			Class[] types = new Class [] {
				java.lang.String.class, java.lang.Object.class
			};
			boolean[] canEdit = new boolean [] {
				false, true
			};

			public Class getColumnClass(int columnIndex) {
				return types [columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit [columnIndex];
			}
		});
		jScrollPane2.setViewportView(propertyTable);

		jPanel1.add(jScrollPane2, java.awt.BorderLayout.CENTER);

		targetLabel.setFont(new java.awt.Font("Dialog", 1, 14));
		targetLabel.setForeground((java.awt.Color) javax.swing.UIManager.getDefaults().get("CheckBoxMenuItem.acceleratorForeground"));
		targetLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		targetLabel.setText("Schema");
		targetLabel.setBorder(new javax.swing.border.EtchedBorder());
		jPanel1.add(targetLabel, java.awt.BorderLayout.NORTH);

		jSplitPane1.setRightComponent(jPanel1);

		jPanel2.setLayout(new java.awt.BorderLayout());

		jScrollPane1.setViewportView(tree);

		jPanel2.add(jScrollPane1, java.awt.BorderLayout.CENTER);

		jSplitPane1.setLeftComponent(jPanel2);

		add(jSplitPane1, java.awt.BorderLayout.CENTER);
		addCubeButton.setIcon(new javax.swing.ImageIcon("images/addCube24.gif"));
		addCubeButton.setToolTipText("Add Cube");
		addCubeButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			addCube(evt);
		}
	});
		jToolBar1.add(addCubeButton);

		addDimensionButton.setIcon(new javax.swing.ImageIcon("images/addDimension24.gif"));
		addDimensionButton.setToolTipText("Add Dimension");
		addDimensionButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			addDimension(evt);
		}
	});
		jToolBar1.add(addDimensionButton);

		addMeasureButton.setIcon(new javax.swing.ImageIcon("images/addMeasure24.gif"));
		addMeasureButton.setToolTipText("Add Measure");
		addMeasureButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			addMeasure(evt);
		}
	});

		jToolBar1.add(addMeasureButton);

		addLevelButton.setIcon(new javax.swing.ImageIcon("images/addLevel24.gif"));
		addLevelButton.setToolTipText("Add Level");
		addLevelButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			addLevel(evt);
		}
	});
		jToolBar1.add(addLevelButton);

		addPropertyButton.setIcon(new javax.swing.ImageIcon("images/addProperty24.gif"));
		addPropertyButton.setToolTipText("Add Property");
		addPropertyButton.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			addProperty(evt);
		}
	});
		jToolBar1.add(addPropertyButton);

		jPanel3.setMaximumSize(new java.awt.Dimension(10, 32767));
		jToolBar1.add(jPanel3);

		cutButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/toolbarButtonGraphics/general/Cut24.gif")));
		cutButton.setToolTipText("Cut");
		jToolBar1.add(cutButton);

		copyButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/toolbarButtonGraphics/general/Copy24.gif")));
		copyButton.setToolTipText("Copy");
		jToolBar1.add(copyButton);

		pasteButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/toolbarButtonGraphics/general/Paste24.gif")));
		pasteButton.setToolTipText("Paste");
		jToolBar1.add(pasteButton);

		add(jToolBar1, java.awt.BorderLayout.NORTH);

	}//GEN-END:initComponents

	/**
	 * @param evt
	 */
	protected void addCube(ActionEvent evt) {
		MondrianDef.Schema schema = (Schema) tree.getModel().getRoot();
		MondrianDef.Cube cube =new MondrianDef.Cube();
		cube.name = "New Cube"+schema.cubes.length;;
		cube.dimensions = new MondrianDef.Dimension[0];
		cube.measures = new MondrianDef.Measure[0];
		cube.fact = new MondrianDef.Table();

		//add cube to schema
		mondrian.xom.NodeDef[] temp = null;		
		temp = schema.cubes;
		schema.cubes = new MondrianDef.Cube[temp.length+1];
		for(int _i=0; _i<temp.length; _i++)
			schema.cubes[_i] = (MondrianDef.Cube)temp[_i];
				
		schema.cubes[schema.cubes.length-1] = cube;
		refreshTree(tree.getSelectionPath());

	}

	/**
	 * Updates the tree display after an Add / Delete operation.
	 */
	private void refreshTree(TreePath path) {
		model.fireTreeChanged(path);
		tree.expandPath(path);
		tree.setSelectionPath(path);
		tree.requestFocus();
	}

	/**
	 * @param evt
	 */
	protected void addMeasure(ActionEvent evt) {
		Object path = tree.getSelectionPath().getLastPathComponent();
		if( ! (path instanceof MondrianDef.Cube) ) return;		
		MondrianDef.Cube cube = (MondrianDef.Cube) path;
		
		MondrianDef.Measure measure = new MondrianDef.Measure();
		measure.name = "New Measure"+cube.measures.length;
		//add cube to schema
		mondrian.xom.NodeDef[] temp;		
		
		temp = cube.measures;
		cube.measures = new MondrianDef.Measure[temp.length+1];
		for(int i=0; i<temp.length; i++)
			cube.measures[i] = (MondrianDef.Measure) temp[i];
				
		cube.measures[cube.measures.length-1] = measure;
		
		// set model
		refreshTree(tree.getSelectionPath());
		//tree.setSelectionPath(tree.getSelectionPath().pathByAddingChild(measure));

		//model = new SchemaTreeModel(schema);
		//tree.setModel(model);
	}

	/**
	 * @param evt
	 */
	protected void addDimension(ActionEvent evt) {
		MondrianDef.Schema schema = (Schema) tree.getModel().getRoot();
		Object path = tree.getSelectionPath().getLastPathComponent();
		if( ! (path instanceof MondrianDef.Cube) ) return;		

		MondrianDef.Cube cube = (MondrianDef.Cube) path;
		
		MondrianDef.Dimension dimension = new MondrianDef.Dimension();
		dimension.name = "New Dimension"+cube.dimensions.length;
		dimension.hierarchies = new MondrianDef.Hierarchy[1];
		dimension.hierarchies[0] = new MondrianDef.Hierarchy();
		dimension.hierarchies[0].hasAll = new Boolean(false);
		dimension.hierarchies[0].levels = new MondrianDef.Level[0];
		dimension.hierarchies[0].memberReaderParameters = new MondrianDef.Parameter[0];
		dimension.hierarchies[0].relation = new MondrianDef.Join();

		//add cube to schema
		mondrian.xom.NodeDef[] temp = null;		
		temp = cube.dimensions;
		cube.dimensions = new MondrianDef.CubeDimension[temp.length+1];
		for(int i=0; i<temp.length; i++)
			cube.dimensions[i] = (MondrianDef.CubeDimension)temp[i];
				
		cube.dimensions[cube.dimensions.length-1] = dimension;

		refreshTree(tree.getSelectionPath());
		//tree.setSelectionPath(tree.getSelectionPath().pathByAddingChild(dimension));
	}

	/**
	 * @param evt
	 */
	protected void addLevel(ActionEvent evt) {
		MondrianDef.Schema schema = (Schema) tree.getModel().getRoot();
		Object path = tree.getSelectionPath().getLastPathComponent();
		if( ! (path instanceof MondrianDef.Hierarchy) ) return;		

		MondrianDef.Hierarchy hierarchy = (MondrianDef.Hierarchy) path;
		
		MondrianDef.Level level = new MondrianDef.Level();
		level.uniqueMembers = new Boolean(false);
		level.name = "New Level"+hierarchy.levels.length;
		level.properties = new MondrianDef.Property[0];
		level.nameExp = new MondrianDef.NameExpression();
		level.nameExp.expressions = new MondrianDef.SQL[1];
		level.nameExp.expressions[0] = new MondrianDef.SQL();
		level.ordinalExp = new MondrianDef.OrdinalExpression();
		level.ordinalExp.expressions = new MondrianDef.SQL[1];
		level.ordinalExp.expressions[0] = new MondrianDef.SQL();
		//dimension.hierarchies[0].memberReaderParameters[0] = new MondrianDef.Parameter();

		//add cube to schema
		mondrian.xom.NodeDef[] temp = null;		
		temp = hierarchy.levels;
		hierarchy.levels = new MondrianDef.Level[temp.length+1];
		for(int i=0; i<temp.length; i++)
			hierarchy.levels[i] = (MondrianDef.Level)temp[i];
				
		hierarchy.levels[hierarchy.levels.length-1] = level;

		refreshTree(tree.getSelectionPath());
		//tree.setSelectionPath(tree.getSelectionPath().pathByAddingChild(level));
	}

	/**
	 * @param evt
	 */
	protected void addProperty(ActionEvent evt) {
		MondrianDef.Schema schema = (Schema) tree.getModel().getRoot();
		Object path = tree.getSelectionPath().getLastPathComponent();
		if( ! (path instanceof MondrianDef.Level) ) return;		

		MondrianDef.Level level = (MondrianDef.Level) path;
		
		MondrianDef.Property property = new MondrianDef.Property();

		//add cube to schema
		mondrian.xom.NodeDef[] temp = null;		
		temp = level.properties;
		level.properties = new MondrianDef.Property[temp.length+1];
		for(int i=0; i<temp.length; i++)
		level.properties[i] = (MondrianDef.Property)temp[i];
				
		level.properties[level.properties.length-1] = property;

		refreshTree(tree.getSelectionPath());
		//tree.setSelectionPath(tree.getSelectionPath().pathByAddingChild(level));
	}
	public MondrianDef.Schema getSchema() {
		return this.schema;
	}
    
	public File getSchemaFile() {
		return this.schemaFile;
	}
    
	public void setSchemaFile(File f) {
		this.schemaFile = f;
	}
    
	/**
	 * Called whenever the value of the selection changes.
	 * @param e the event that characterizes the change.
	 *
	 */
	public void valueChanged(TreeSelectionEvent e) {
		Object o = e.getPath().getLastPathComponent();
		String[] pNames = DEF_DEFAULT;
		if (o instanceof MondrianDef.Column) {
			pNames = DEF_COLUMN;  
			targetLabel.setText("Column");
		} else if (o instanceof MondrianDef.Cube) {
			pNames = DEF_CUBE;  
			targetLabel.setText("Cube");
		} else if (o instanceof MondrianDef.Dimension) {
			pNames = DEF_DIMENSION;  
			targetLabel.setText("Dimension");
		} else if (o instanceof MondrianDef.DimensionUsage) {
			pNames = DEF_DIMENSION_USAGE;  
			targetLabel.setText("Dimension Usage");
		} else if (o instanceof MondrianDef.ExpressionView) {
			pNames = DEF_EXPRESSION_VIEW;  
			targetLabel.setText("Expression View");
		} else if (o instanceof MondrianDef.Hierarchy) {
			pNames = DEF_HIERARCHY;  
			targetLabel.setText("Hierarchy");
		} else if (o instanceof MondrianDef.Join) {
			pNames = DEF_JOIN;  
			targetLabel.setText("Join");
		} else if (o instanceof MondrianDef.Level) {
			pNames = DEF_LEVEL;  
			targetLabel.setText("Level");
		} else if (o instanceof MondrianDef.Measure) {
			pNames = DEF_MEASURE;  
			targetLabel.setText("Measure");
		} else if (o instanceof MondrianDef.Parameter) {
			pNames = DEF_PARAMETER;                
			targetLabel.setText("Parameter");
		} else if (o instanceof MondrianDef.Property) {
			pNames = DEF_PROPERTY;
			targetLabel.setText("Property");
		} else if (o instanceof MondrianDef.Schema) {
			pNames = DEF_SCHEMA;
			targetLabel.setText("Schema");
		} else if (o instanceof MondrianDef.SQL) {
			pNames = DEF_SQL;
			targetLabel.setText("SQL");
		} else if (o instanceof MondrianDef.Table) {
			pNames = DEF_TABLE;
			targetLabel.setText("Table");
		} else if (o instanceof MondrianDef.View) {
			pNames = DEF_VIEW;
			targetLabel.setText("View");
		} else if (o instanceof MondrianDef.VirtualCube) {
			pNames = DEF_VIRTUAL_CUBE;
			targetLabel.setText("Virtual Cube");
		} else if (o instanceof MondrianDef.VirtualCubeDimension) {
			pNames = DEF_VIRTUAL_CUBE_DIMENSION;
			targetLabel.setText("Virtual Cube Dimension");
		} else if (o instanceof MondrianDef.VirtualCubeMeasure) {
			pNames = DEF_VIRTUAL_CUBE_MEASURE;
			targetLabel.setText("Virtual Cube Measure");
		} else {
			targetLabel.setText("Unknown Type");
		}
		PropertyTableModel ptm = new PropertyTableModel(o,pNames); 
		propertyTable.setModel(ptm);
		
		for (int i=0; i < propertyTable.getRowCount(); i++) {
			TableCellRenderer renderer = propertyTable.getCellRenderer( i, 1);
			Component comp = renderer.getTableCellRendererComponent(propertyTable, propertyTable.getValueAt(i, 1), false, false, i, 1);
			try {
				int height = comp.getMaximumSize().height;
				propertyTable.setRowHeight(i, height);
			}
			catch(Exception ea) {}

		}

	}    
    
	public static final String[] DEF_DEFAULT = {};
	public static final String[] DEF_VIRTUAL_CUBE = {"name"};
	public static final String[] DEF_VIRTUAL_CUBE_MEASURE = {"name", "cubeName"};
	public static final String[] DEF_VIRTUAL_CUBE_DIMENSION = {"cubeName"};
	public static final String[] DEF_VIEW = {"alias"};
	public static final String[] DEF_TABLE = {"name", "alias", "schema"};
	public static final String[] DEF_RELATION = {"name"};
	public static final String[] DEF_SQL = {"cdata", "dialect"};
	public static final String[] DEF_SCHEMA = {};
	public static final String[] DEF_PROPERTY = {"name", "column", "type"};
	public static final String[] DEF_PARAMETER = {"name", "value"};
	public static final String[] DEF_MEASURE = {"name", "aggregator", "column", "formatString"};
	public static final String[] DEF_LEVEL = {"name", "column", "nameExp", "ordinalColumn", "ordinalExp", "table", "type", "uniqueMembers"};
	public static final String[] DEF_JOIN = {"left", "leftAlias", "leftKey", "right", "rightAlias", "rightKey"};
	public static final String[] DEF_HIERARCHY = {"hasAll", "defaultMember", "memberReaderClass", "primaryKey", "primaryKeyTable", "relation"};
	public static final String[] DEF_EXPRESSION_VIEW = {};
	public static final String[] DEF_DIMENSION_USAGE = {"name", "foreignKey", "source"};
	public static final String[] DEF_DIMENSION = {"name", "foreignKey"};
	public static final String[] DEF_CUBE = {"name", "fact"};
	public static final String[] DEF_COLUMN = {"name", "table"};

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JPanel jPanel3;
	private javax.swing.JTable propertyTable;
	private javax.swing.JPanel jPanel2;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JButton addLevelButton;
	private javax.swing.JScrollPane jScrollPane2;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JButton addPropertyButton;
	private javax.swing.JButton pasteButton;
	private javax.swing.JLabel targetLabel;
	private javax.swing.JTree tree;
	private javax.swing.JSplitPane jSplitPane1;
	private javax.swing.JButton addDimensionButton;
	private javax.swing.JButton cutButton;
	private javax.swing.JButton addMeasureButton;
	private javax.swing.JButton addCubeButton;
	private javax.swing.JButton copyButton;
	private javax.swing.JToolBar jToolBar1;
    

}
