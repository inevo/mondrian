/*
// $Id$
// This software is subject to the terms of the Common Public License
// Agreement, available at the following URL:
// http://www.opensource.org/licenses/cpl.html.
// Copyright (C) 2005-2005 Kana Software, Inc. and others.
// All Rights Reserved.
// You must accept the terms of that agreement to use this software.
*/

package mondrian.rolap.aggmatcher;


import mondrian.olap.MondrianProperties;
import mondrian.olap.MondrianResource;
import mondrian.rolap.*;
import org.apache.log4j.Logger;
import org.eigenbase.xom.*;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

/**
 * This class is a container for the default aggregate recognition rules.
 * It is generated by parsing the default rule xml information found
 * in the {@link MondrianProperties#AggregateRules} value which normally is
 * a resource in the jar file (but can be a url).
 *
 * <p>It is a singleton since it is used to recognize tables independent of
 * database connection (each {@link RolapSchema} uses the same instance).
 *
 * @author <a>Richard M. Emberson</a>
 * @version $Id$
 */
public class DefaultRules {

    private static final Logger LOGGER = Logger.getLogger(DefaultRules.class);

    private static final MondrianResource mres = MondrianResource.instance();
    /**
     * There is a single instance of the {@link DefaultRecognizer} and the
     * {@link DefaultRules} class is a container of that instance.
     */
    public static synchronized DefaultRules getInstance() {
        if (instance == null) {
            InputStream inStream = getAggRuleInputStream();
            if (inStream  == null) {
                return null;
            }

            DefaultDef.AggRules defs = makeAggRules(inStream);

            // validate the DefaultDef.AggRules object
            Recorder.Lists reclists = new Recorder.Lists();
            try {
                defs.validate(reclists);
            } catch (MessageRecorder.RTException e) {
                // ignore
            }

            reclists.logWarningMessage(LOGGER);
            reclists.logErrorMessage(LOGGER);

            if (reclists.hasErrors()) {
                reclists.throwRTException();
            }


            // make sure the tag name exists
            String tag = MondrianProperties.instance().getAggregateRuleTag();
            DefaultDef.AggRule aggrule = defs.getAggRule(tag);
            if (aggrule == null) {
                throw mres.newMissingDefaultAggRule(tag);
            }

            DefaultRules rules = new DefaultRules(defs);
            rules.setTag(tag);
            instance = rules;
        }
        return instance;
    }
    private static InputStream getAggRuleInputStream() {
        String aggRules = MondrianProperties.instance().getAggregateRules();

        InputStream inStream = DefaultRules.class.getResourceAsStream(aggRules);
        if (inStream == null) {
            try {
                URL url = new URL(aggRules);
                inStream = url.openStream();
            } catch (MalformedURLException e) {
                // ignore
            } catch (IOException e) {
                // ignore
            }
        }
        if (inStream == null) {
            String msg = mres.getCouldNotLoadDefaultAggregateRules(aggRules);
            LOGGER.warn(msg);
        }
        return inStream;
    }
    private static DefaultRules instance = null;

    static {
        // When the value of the AggregateRules property is changed, force
        // system to reload the DefaultRules.
        // There is no need to provide equals/hashCode methods for this
        // Trigger since it is a singleton and is never removed.
        MondrianProperties.Trigger trigger = null;

        trigger =
            new MondrianProperties.Trigger() {
                public boolean isPersistent() {
                    return true;
                }
                public int phase() {
                    return MondrianProperties.Trigger.PRIMARY_PHASE;
                }
                public void executeTrigger(final String key,
                                           final String value)
                             throws MondrianProperties.Trigger.VetoRT {
                    synchronized (DefaultRules.class) {
                        DefaultRules oldInstance = DefaultRules.instance;
                        DefaultRules.instance = null;

                        DefaultRules newinstance = null;
                        Exception ex = null;
                        try {
                            newinstance = DefaultRules.getInstance();
                        } catch (Exception e) {
                            ex = e;
                        }
                        if (ex != null) {
                            DefaultRules.instance = oldInstance;

                            throw new MondrianProperties.Trigger.VetoRT(ex);

                        } else if (newinstance == null) {
                            DefaultRules.instance = oldInstance;

                            String msg =
                            mres.getFailedCreateNewDefaultAggregateRules(
                                key, value);
                            throw new MondrianProperties.Trigger.VetoRT(msg);

                        } else {
                            instance = newinstance;
                        }
                    }
                }
            };

        MondrianProperties.instance().addTrigger(trigger,
            MondrianProperties.AggregateRules);
        MondrianProperties.instance().addTrigger(trigger,
            MondrianProperties.AggregateRuleTag);


    }

    protected static DefaultDef.AggRules makeAggRules(final File file) {
        DOMWrapper def = makeDOMWrapper(file);
        try {
            DefaultDef.AggRules rules = new DefaultDef.AggRules(def);
            return rules;
        } catch (XOMException e) {
            throw mres.newAggRuleParse(file.getName(),e);
        }
    }
    protected static DefaultDef.AggRules makeAggRules(final URL url) {
        DOMWrapper def = makeDOMWrapper(url);
        try {
            DefaultDef.AggRules rules = new DefaultDef.AggRules(def);
            return rules;
        } catch (XOMException e) {
            throw mres.newAggRuleParse(url.toString(),e);
        }
    }
    protected static DefaultDef.AggRules makeAggRules(
                                            final InputStream inStream) {
        DOMWrapper def = makeDOMWrapper(inStream);
        try {
            DefaultDef.AggRules rules = new DefaultDef.AggRules(def);
            return rules;
        } catch (XOMException e) {
            throw mres.newAggRuleParse("InputStream",e);
        }
    }
    protected static DefaultDef.AggRules makeAggRules(final String text,
                                                      final String name) {
        DOMWrapper def = makeDOMWrapper(text, name);
        try {
            DefaultDef.AggRules rules = new DefaultDef.AggRules(def);
            return rules;
        } catch (XOMException e) {
            throw mres.newAggRuleParse(name,e);
        }
    }
    protected static DOMWrapper makeDOMWrapper(final File file) {
        try {
            return makeDOMWrapper(file.toURL());
        } catch (MalformedURLException e) {
            throw mres.newAggRuleParse(file.getName(),e);
        }
    }
    protected static DOMWrapper makeDOMWrapper(final URL url) {
        try {
            final Parser xmlParser = XOMUtil.createDefaultParser();
            DOMWrapper def = xmlParser.parse(url);
            return def;
        } catch (XOMException e) {
            throw mres.newAggRuleParse(url.toString(),e);
        }
    }
    protected static DOMWrapper makeDOMWrapper(final InputStream inStream) {
        try {
            final Parser xmlParser = XOMUtil.createDefaultParser();
            DOMWrapper def = xmlParser.parse(inStream);
            return def;
        } catch (XOMException e) {
            throw mres.newAggRuleParse("InputStream",e);
        }
    }
    protected static DOMWrapper makeDOMWrapper(final String text,
                                               final String name) {
        try {
            final Parser xmlParser = XOMUtil.createDefaultParser();
            DOMWrapper def = xmlParser.parse(text);
            return def;
        } catch (XOMException e) {
            throw mres.newAggRuleParse(name,e);
        }
    }


    private final DefaultDef.AggRules rules;
    private final Map factToPattern;
    private final Map foreignKeyMatcherMap;
    private Recognizer.Matcher factCountMatcher;
    private String tag;

    private DefaultRules(final DefaultDef.AggRules rules) {
        this.rules = rules;
        this.factToPattern = new HashMap();
        this.foreignKeyMatcherMap = new HashMap();
        this.tag = MondrianProperties.AggregateRuleTag_Default;
    }

    public void validate(MessageRecorder msgRecorder) {
        rules.validate(msgRecorder);
    }

    /**
     * Sets the name (tag) of this rule.
     *
     * @param tag
     */
    private void setTag(final String tag) {
        this.tag = tag;
    }

    /**
     * Gets the tag of this rule (this is the value of the
     * {@link MondrianProperties#AggregateRuleTag} property).
     *
     * @return
     */
    public String getTag() {
        return this.tag;
    }


    /**
     * Returns the {@link mondrian.rolap.aggmatcher.DefaultDef.AggRule} whose
     * tag equals this rule's tag.
     */
    public DefaultDef.AggRule getAggRule() {
        return getAggRule(getTag());
    }

    /**
     * Returns the {@link mondrian.rolap.aggmatcher.DefaultDef.AggRule} whose
     * tag equals the parameter tag, or null if not found.
     *
     * @param tag
     * @return the AggRule with tag value equal to tag parameter, or null.
     */
    public DefaultDef.AggRule getAggRule(final String tag) {
        return this.rules.getAggRule(tag);
    }

    /**
     * Gets the {@link mondrian.rolap.aggmatcher.Recognizer.Matcher} for this
     * tableName.
     *
     * @param tableName
     */
    public Recognizer.Matcher getTableMatcher(final String tableName) {
        Recognizer.Matcher matcher =
            (Recognizer.Matcher) factToPattern.get(tableName);
        if (matcher == null) {
            // get default AggRule
            DefaultDef.AggRule rule = getAggRule();
            DefaultDef.TableMatch tableMatch = rule.getTableMatch();
            matcher = tableMatch.getMatcher(tableName);
            factToPattern.put(tableName, matcher);
        }
        return matcher;
    }

    /**
     * Gets the {@link mondrian.rolap.aggmatcher.Recognizer.Matcher} for the
     * fact count column.
     */
    public Recognizer.Matcher getFactCountMatcher() {
        if (factCountMatcher == null) {
            // get default AggRule
            DefaultDef.AggRule rule = getAggRule();
            DefaultDef.FactCountMatch factCountMatch =
                rule.getFactCountMatch();
            factCountMatcher = factCountMatch.getMatcher();
        }
        return factCountMatcher;
    }

    /**
     * Gets the {@link mondrian.rolap.aggmatcher.Recognizer.Matcher} for this
     * foreign key column name.
     *
     * @param foreignKeyName
     */
    public Recognizer.Matcher getForeignKeyMatcher(String foreignKeyName) {
        Recognizer.Matcher matcher =
            (Recognizer.Matcher) foreignKeyMatcherMap.get(foreignKeyName);
        if (matcher == null) {
            // get default AggRule
            DefaultDef.AggRule rule = getAggRule();
            DefaultDef.ForeignKeyMatch foreignKeyMatch =
                rule.getForeignKeyMatch();
            matcher = foreignKeyMatch.getMatcher(foreignKeyName);
            foreignKeyMatcherMap.put(foreignKeyName, matcher);
        }
        return matcher;
    }

    /**
     * Returns true if this candidate aggregate table name "matches" the
     * factTableName.
     *
     * @param factTableName
     * @param name candidate aggregate table name
     * @return
     */
    public boolean matchesTableName(final String factTableName,
                                    final String name) {
        Recognizer.Matcher matcher = getTableMatcher(factTableName);
        return matcher.matches(name);
    }

    /**
     * Creates a {@link mondrian.rolap.aggmatcher.Recognizer.Matcher} for the
     * given measure name (symbolic name), column name and aggregate name
     * (sum, count, etc.).
     *
     * @param measureName
     * @param measureColumnName
     * @param aggregateName
     * @return
     */
    public Recognizer.Matcher getMeasureMatcher(final String measureName,
                                                final String measureColumnName,
                                                final String aggregateName) {
        DefaultDef.AggRule rule = getAggRule();
        Recognizer.Matcher matcher =
            rule.getMeasureMap().getMatcher(measureName,
                                            measureColumnName,
                                            aggregateName);
        return matcher;
    }

    /**
     * Gets a {@link mondrian.rolap.aggmatcher.Recognizer.Matcher} for a given
     * level's hierarchy's name, level name and column name.
     *
     * @param hierarchyName
     * @param levelName
     * @param levelColumnName
     * @return
     */
    public Recognizer.Matcher getLevelMatcher(final String hierarchyName,
                                              final String levelName,
                                              final String levelColumnName) {
        DefaultDef.AggRule rule = getAggRule();
        Recognizer.Matcher matcher =
            rule.getLevelMap().getMatcher(hierarchyName,
                                          levelName,
                                          levelColumnName);
        return matcher;
    }

    /**
     * Uses the {@link DefaultRecognizer} Recognizer to determine if the
     * given aggTable's columns all match upto the dbFactTable's columns (where
     * present) making the column usages as a result.
     *
     * @param star
     * @param dbFactTable
     * @param aggTable
     * @param msgRecorder
     * @return
     */
    public boolean columnsOK(
            final RolapStar star,
            final JdbcSchema.Table dbFactTable,
            final JdbcSchema.Table aggTable,
            final MessageRecorder msgRecorder) {
        Recognizer cb = new DefaultRecognizer(
                this,
                star,
                dbFactTable,
                aggTable,
                msgRecorder);
        return cb.check();
    }
}

// End DefaultRules.java
