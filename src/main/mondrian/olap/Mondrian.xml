<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../../../../misc/Meta.xsl" ?>
<!--
  == $Id$
  == This software is subject to the terms of the Common Public License
  == Agreement, available at the following URL:
  == http://www.opensource.org/licenses/cpl.html.
  == (C) Copyright 2001-2002 Kana Software, Inc. and others.
  == All Rights Reserved.
  == You must accept the terms of that agreement to use this software.
  ==
  == This file defines an MMM schema for an Olap schema.
  -->
<Model
 name="mondrian"
 dtdName="mondrian.dtd"
 className="MondrianDef"
 packageName="mondrian.olap"
 root="Schema"
 version="1.0">
	<Doc>
This is the XML model for Mondrian schemas.
<p/>
Revision is $Id$
	</Doc>

	<!-- Schema ========================================================== -->
	<Element type="Schema">
		<Doc>
			A schema is a collection of cubes and shared dimensions.
		</Doc>
		<Array name="dimensions" type="Dimension"/>
		<Array name="cubes" type="Cube"/>
		<Array name="virtualCubes" type="VirtualCube"/>
		<Code><![CDATA[
			Cube getCube(String cubeName) {
				for (int i = 0; i < cubes.length; i++) {
					if (cubes[i].name.equals(cubeName)) {
						return cubes[i];
					}
				}
				throw Util.newInternal("Cannot find cube '" + cubeName + "'");
			}
			Dimension getPublicDimension(String dimensionName) {
				for (int i = 0; i < dimensions.length; i++) {
					if (dimensions[i].name.equals(dimensionName)) {
						return dimensions[i];
					}
				}
				throw Util.newInternal(
					"Cannot find public dimension '" + dimensionName + "'");
			}]]>
		</Code>
	</Element>

	<!-- CubeDimension ==================================================== -->
	<Class class="CubeDimension">
		<Doc>
			A CubeDimension is either a usage of a Dimension ('shared
			dimension', in MSOLAP parlance), or a 'private dimension'.
		</Doc>
		<Attribute name="name" required="true"/>
		<Attribute name="foreignKey">
			<Doc>
				The name of the column in the fact table which joins
				to the leaf level of this dimension. Required in a
				private Dimension or a DimensionUsage, but not in a
				public Dimension.
			</Doc>
		</Attribute>
		<Code>
			public abstract Dimension getDimension(Schema schema);
		</Code>
	</Class>

	<!-- Cube ============================================================ -->
	<Element type="Cube">
		<Doc>
todo:
	</Doc>
		<Attribute name="name" required="true"><Doc></Doc></Attribute>
		<Attribute name="factTable" required="true"><Doc>todo: move to mapping</Doc></Attribute>
		<Attribute name="factSchema" required="false">
			<Doc>
				Qualifier for the fact table. If not present, the fact table
				name is left unqualified.
			</Doc>
		</Attribute>
		<Array name="dimensions" type="CubeDimension"><Doc></Doc></Array>
		<Array name="measures" type="Measure"><Doc></Doc></Array>
		<Code><![CDATA[
			Dimension getDimension(Schema xmlSchema, String dimensionName) {
				for (int i = 0; i < dimensions.length; i++) {
					if (dimensions[i].name.equals(dimensionName)) {
						return dimensions[i].getDimension(xmlSchema);
					}
				}
				throw Util.newInternal(
					"Cannot find dimension '" + dimensionName + "' in cube '" +
					name + "'");
			}]]>
		</Code>
	</Element>

	<!-- VirtualCube ====================================================== -->
	<Element type="VirtualCube">
		<Doc>
			A <code>VirtualCube</code> is a set of dimensions and
			measures gleaned from other cubes.
		</Doc>
		<Attribute name="name"><Doc></Doc></Attribute>
		<Array name="dimensions" type="VirtualCubeDimension"><Doc></Doc></Array>
		<Array name="measures" type="VirtualCubeMeasure"><Doc></Doc></Array>
	</Element>

	<!-- VirtualCubeDimension ============================================= -->
	<Element type="VirtualCubeDimension" class="CubeDimension">
		<Doc>
			A VirtualCubeDimension is a usage of a Dimension in a VirtualCube.
		</Doc>
		<Attribute name="cubeName">
			<Doc>
				Name of the cube which the dimension belongs to, or
				unspecified if the dimension is shared.
			</Doc>
		</Attribute>
		<Attribute name="name"><Doc>
			Name of the dimension.</Doc></Attribute>
		<Code><![CDATA[
			// implement CubeDimension
			public Dimension getDimension(Schema schema) {
				if (cubeName == null) {
					return schema.getPublicDimension(name);
				} else {
					Cube cube = schema.getCube(cubeName);
					return cube.getDimension(schema, name);
				}
			}]]>
		</Code>
	</Element>

	<!-- VirtualCubeMeasure =============================================== -->
	<Element type="VirtualCubeMeasure">
		<Doc>
			A VirtualCubeMeasure is a usage of a Measure in a VirtualCube.
		</Doc>
		<Attribute name="cubeName">
			<Doc>
				Name of the cube which the measure belongs to.
			</Doc>
		</Attribute>
		<Attribute name="name">
			<Doc>
				Unique name of the measure within its cube.
			</Doc>
		</Attribute>
	</Element>

	<!-- DimensionUsage =================================================== -->
	<Element type="DimensionUsage" class="CubeDimension">
		<Doc>
			A <code>DimensionUsage</code> is usage of a shared
			Dimension within the context of a cube.
		</Doc>
		<Attribute name="source" required="true">
			<Doc>Name of the source dimension. Must be a dimension in
			this schema. Case-sensitive.</Doc>
		</Attribute>
		<Code><![CDATA[
			// implement CubeDimension
			public Dimension getDimension(Schema schema) {
				for (int i = 0; i < schema.dimensions.length; i++) {
					if (schema.dimensions[i].name.equals(source)) {
						return schema.dimensions[i];
					}
				}
				throw Util.newInternal(
					"Cannot find shared dimension '" + source + "'");
			}]]>
		</Code>
	</Element>

	<!-- Dimension ======================================================== -->
	<Element type="Dimension" class="CubeDimension">
		<Doc>
			A <code>Dimension</code> is a collection of hierarchies. There are
			two kinds: a <dfn>public</dfn> dimension belongs to a <link
			class="Schema">schema</link>, and be used by several cubes; a
			<dfn>private</dfn> dimension belongs to a
			<link class="Cube">cube</link>. The
			<link member="foreignKey">foreignKey</link> field is only
			applicable to private dimensions.
		</Doc>
		<Attribute name="name"><Doc></Doc></Attribute>
		<Array name="hierarchies" type="Hierarchy"><Doc></Doc></Array>
		<Code>
			// implement CubeDimension
			public Dimension getDimension(Schema schema) {
				return this;
			}
		</Code>
	</Element>

	<Element type="Hierarchy">
		<Doc>
			Defines a hierarchy.
			
			<p/>You must specify precisely one of <code>&lt;Relation&gt;</code>
			 and <code>memberReaderClass</code>.
		</Doc>
		<Attribute name="name" required="false">
			<Doc>
				Name of the hierarchy. If this is not specified, the hierarchy
				has the same name as its dimension.
			</Doc>
		</Attribute>
		<Attribute name="hasAll" type="Boolean" required="true">
			<Doc>
			</Doc>
		</Attribute>
		<Attribute name="primaryKey">
			<Doc>
				The name of the column which identifies members, and
				which is referenced by rows in the fact table. See
				also <link class="CubeDimension"
				member="foreignKey">CubeDimension.foreignKey</link>.
			</Doc>
		</Attribute>
		<Attribute name="primaryKeyTable">
			<Doc>
				The name of the table which contains <code>primaryKey</code>.
				If the hierarchy has only one table, defaults to that;
				it is required.
			</Doc>
		</Attribute>
		<Attribute name="defaultMember"><Doc></Doc></Attribute>
		<Attribute name="memberReaderClass">
			<Doc>
				Name of the custom member reader class. Must implement
				{@link Broadbase.olap.RolapConnection.MemberReader}.
			</Doc>
		</Attribute>
		<Object name="relation" type="Relation">
			<Doc>
				The {@link #Table table}, {@link #Join set of tables}, or
				{@link #View SQL statement} which populates this hierarchy.
			</Doc>
		</Object>
		<Array name="levels" type="Level"><Doc></Doc></Array>
		<Array name="memberReaderParameters" type="Parameter"/>
	</Element>

	<Element type="Level">
		<Attribute name="name"><Doc></Doc></Attribute>
		<Attribute name="table" required="false">
			<Doc>
				The name of the table that the column comes from. If
				this hierarchy is based upon just one table, defaults to
				the name of that table; otherwise, it is required.
			</Doc>
		</Attribute>
		<Attribute name="column"><Doc>todo:</Doc></Attribute>
		<Attribute name="ordinalColumn" required="false">
			<Doc>
				The name of the column which holds member
				ordinals. Only applicable for the last level in a
				hierarchy. If this column is not specified, the
				hierarchy cannot be implemented in ROLAP mode.
			</Doc>
		</Attribute>
		<Attribute name="type" default="String">
			<Doc>todo:</Doc>
			<Value>String</Value>
			<Value>Numeric</Value>
		</Attribute>
		<Attribute name="uniqueMembers" type="Boolean" default="false">
			<Doc>
				Whether members are unique across all parents. For
				example, zipcodes are unique across all states. The
				first level's members are always unique.
			</Doc>
		</Attribute>
		<Object name="nameExp" type="Expression" required="false">
			<Doc>
				The SQL expression used to populate this level's name.
			</Doc>
		</Object>
		<Object name="ordinalExp" type="Expression" required="false">
			<Doc>
				The SQL expression used to populate this level's ordinal.
			</Doc>
		</Object>
		<Array name="properties" type="Property" min="0"/>
		<Code>
			public Expression getNameExp() {
				if (nameExp != null) {
					return nameExp;
				} else if (column != null) {
					return new Column(table, column);
				} else {
					return null;
				}
			}
			public Expression getOrdinalExp() {
				if (ordinalExp != null) {
					return ordinalExp;
				} else if (ordinalColumn != null) {
					return new Column(table, ordinalColumn);
				} else {
					return null;
				}
			}
			public Expression getPropertyExp(int i) {
				return new Column(table, properties[i].column);
			}
		</Code>
	</Element>

	<Element type="Property">
		<Doc>
			Member property.
		</Doc>
		<Attribute name="name"><Doc></Doc></Attribute>
		<Attribute name="column"><Doc></Doc></Attribute>
		<Attribute name="type" default="String">
			<Doc>todo:</Doc>
			<Value>String</Value>
			<Value>Numeric</Value>
			<Value>Boolean</Value>
		</Attribute>
	</Element>

	<Element type="Measure">
		<Attribute name="name"><Doc></Doc></Attribute>
		<Attribute name="column"><Doc>todo:</Doc></Attribute>
		<Attribute name="formatString">
			<Doc>
				Format string with which to format cells of this measure. For
				more details, see {@link mondrian.util.Format}.
			</Doc>
		</Attribute>
		<Attribute name="aggregator">
			<Doc>todo:</Doc>
			<Value>sum</Value>
			<Value>count</Value>
		</Attribute>
	</Element>

	<Element type="Parameter">
		<Attribute name="name"/>
		<Attribute name="value"/>
	</Element>

	<Class class="Relation">
		<Doc>A table or a join</Doc>
		<Code>
			public abstract Relation find(String seekAlias);
 			public abstract String getAlias();
		</Code>
	</Class>

	<Element type="View" class="Relation">
		<Doc>
			A collection of SQL statements, one per dialect.
		</Doc>
		<Attribute name="alias" required="true"/>
		<Array name="selects" type="SQL" min="1"/>
		<Code>
			public String toString() {
				return selects[0].cdata;
			}
			public Relation find(String seekAlias) {
				if (seekAlias.equals(alias)) {
					return this;
				} else {
					return null;
				}
			}
 			public String getAlias() {
				return alias;
			}
			</Code>
	</Element>

	<Element type="SQL">
		<Attribute name="dialect" default="generic">
			<Doc>
				Dialect of SQL the view is intended for.
			</Doc>
			<Value>generic</Value>
			<Value>oracle</Value>
			<Value>mysql</Value>
			<Value>access</Value>
			<Value>postgres</Value>
			<Value>hsqldb</Value>
			<Value>mssql</Value>
		</Attribute>
		<CData/>
	</Element>

	<Element type="Join" class="Relation">
		<Attribute name="leftAlias">
			<Doc>
				Defaults to left's alias if left is a table, otherwise
				required.
			</Doc>
		</Attribute>
		<Attribute name="leftKey" required="true"/>
		<Attribute name="rightAlias">
			<Doc>
				Defaults to right's alias if right is a table, otherwise
				required.
			</Doc>
		</Attribute>
		<Attribute name="rightKey" required="true"/>
		<Object name="left" type="Relation" required="true"/>
		<Object name="right" type="Relation" required="true"/>
		<Code>
			/**
			  * Returns the alias of the left join key, defaulting to left's
			  * alias if left is a table.
			  **/
			public String getLeftAlias() {
				if (leftAlias != null) {
					return leftAlias;
				}
				if (left instanceof Table) {
					return ((Table) left).getAlias();
				}
				throw Util.newInternal(
					"alias is required because " + left + " is not a table");
			}
			/**
			  * Returns the alias of the right join key, defaulting to right's
			  * alias if right is a table.
			  **/
			public String getRightAlias() {
				if (rightAlias != null) {
					return rightAlias;
				}
				if (right instanceof Table) {
					return ((Table) right).getAlias();
				}
				throw Util.newInternal(
					"alias is required because " + right + " is not a table");
			}
			public String toString() {
				return "(" + left + ") join (" + right + ") on " +
					leftAlias + "." + leftKey + " = " +
					rightAlias + "." + rightKey;
			}
			public Relation find(String seekAlias) {
				Relation relation = left.find(seekAlias);
				if (relation == null) {
					relation = right.find(seekAlias);
				}
				return relation;
			}
 			public String getAlias() {
				throw Util.newInternal("join does not have alias");
			}
		</Code>
	</Element>

	<Element type="Table" class="Relation">
		<Attribute name="name" required="true"/>
		<Attribute name="schema">
			<Doc>
				Optional qualifier for <code>table</code>.
			</Doc>
		</Attribute>
		<Attribute name="alias">
			<Doc>
				Alias to be used with this table when it is used to
				form queries. If not specified, defaults to the table
				name, but in any case, must be unique within the
				schema. (You can use the same table in different
				hierarchies, but it must have different aliases.)
			</Doc>
		</Attribute>
		<Code>
			/** Convenience contructor. **/
			public Table(String schema, String name, String alias) {
				this();
				this.schema = schema;
				this.name = name;
				this.alias = alias;
			}
			/** Returns the alias or, if it is null, the table name. **/
			public String getAlias() {
				if (alias != null) {
					return alias;
				}
				return name;
			}
			public String toString() {
				if (schema == null) {
					return name;
				} else {
					return schema + "." + name;
				}
			}
			public Relation find(String seekAlias) {
				if (seekAlias.equals(getAlias())) {
					return this;
				} else {
					return null;
				}
			}
		</Code>
	</Element>

	<Class class="Expression">
		<Code>
			public abstract String getExpression(mondrian.rolap.sql.SqlQuery query);
			public abstract String getTableAlias();
		</Code>
	</Class>

	<Element type="Column" class="Expression">
		<Attribute name="table">
			<Doc>
				Alias of the table which contains this column. Not required if
				the query only has one table.
			</Doc>
		</Attribute>
		<Attribute name="name" required="true">
			<Doc>
				Name of the column.
			</Doc>
		</Attribute>
		<Code>
			/** Convenience contructor. **/
			public Column(String table, String name) {
				this();
				Util.assertTrue(name != null);
				this.table = table;
				this.name = name;
			}
			public String getExpression(mondrian.rolap.sql.SqlQuery query) {
				return query.quoteIdentifier(table, name);
			}
			public String getTableAlias() {
				return table;
			}
		</Code>
	</Element>

	<Element type="ExpressionView" class="Expression">
		<Doc>
			A collection of SQL expressions, one per dialect.
		</Doc>
		<Array name="expressions" type="SQL" min="1"/>
		<Code>
			public String toString() {
				return expressions[0].cdata;
			}
			public String getExpression(mondrian.rolap.sql.SqlQuery query) {
				return query.chooseQuery(expressions);
			}
			public String getTableAlias() {
				return null;
			}
		</Code>
	</Element>

</Model>

<!-- End Mondrian.xml -->
